On Profit-Maximizing Envy-free Pricing
Venkatesan Guruswami∗
Jason D. Hartline†
Anna R. Karlin∗
David Kempe‡
Claire Kenyon§
Frank McSherry†
Abstract
We study the problem of pricing items for sale to consumers
so as to maximize the seller’s revenue. We assume that for
each consumer, we know the maximum amount he would
be willing to pay for each bundle of items, and want to
find pricings of the items with corresponding allocations that
maximize seller profit and at the same time are envy-free,
which is a natural fairness criterion requiring that consumers
are maximally happy with the outcome they receive given
the pricing. We study this problem for two important classes
of inputs: unit demand consumers, who want to buy at most
one item from among a selection they are interested in, and
single-minded consumers, who want to buy one particular
subset, but only if they can afford it.
We show that computing envy-free prices to maximize
the seller’s revenue is APX-hard in both of these cases, and
give a logarithmic approximation algorithm for them. For
several interesting special cases, we derive polynomial-time
algorithms. Furthermore, we investigate some connections
with the corresponding mechanism design problem, in which
the consumer’s preferences are private values: for this case,
we give a log-competitive truthful mechanism.
1 Introduction
Imagine that we are a company or store in the business
of selling products to consumers. An important aspect
of maximizing the revenue obtained is the pricing of our
products: a low price will attract more customers, while a
high price generates more revenue per sold item. How, then,
should we choose prices optimally? For example, supposing
that customers want to buy bandwidth along subpaths of a
network and are willing to pay up to some amount for the
bandwidth, how should one price the bandwidth along the
links so as to maximize the revenue? This is the flavor of the
∗Department of Computer Science and Engineering,
University of Washington, Seattle, WA 98195. Email:
{venkat,karlin}@cs.washington.edu.
†Microsoft Research Silicon Valley, Mountain View, CA 94043. Email:
{hartline,mcsherry}@microsoft.com.
‡Computer Science Department, University of Southern California, Los
Angeles, CA 90089. Email: dkempe@usc.edu.
§Department of Computer Science, Brown University, Providence, RI
02912. Email: claire@cs.brown.edu.
pricing problems studied in this paper.
More formally, we assume that the seller has m differ-
ent items, and a set of n consumers may be interested in pur-
chasing some of these items. We assume that through market
research or interaction with the consumers, the seller knows
each customer’s valuation for each subset (also called bun-
dle) of items, the largest amount that the customer is willing
to pay for that subset. If a customer buys a subset, his util-
ity is the difference between the valuation and the purchase
price, i.e., the amount of money he “saved” compared to his
valuation.
The seller gets to assign individual prices to the items,
and his goal is to maximize his own revenue, i.e., the sum of
prices of all sold items. Which items are sold is determined
by an allocation of bundles of items to customers (at most
one bundle is allocated to each customer, and such a bundle,
if any, must have nonnegative utility for that customer, since
otherwise the customer will of course not buy the bundle).
We require that this allocation be envy-free, i.e., given the
pricing, no user would prefer to be assigned a different
bundle. The notions of envy-free pricing and allocations
model fair equilibrium pricing in a variety of economic
settings [24]. Envy-freeness is particularly relevant in the
case when there is only a limited supply of some items;
for then, a user interested in buying a bundle at the posted
price may be unable to do so, creating discontent among the
customers.
1.1 Our Results. The pricing problem as defined above is
very general. Even when given envy-free prices, computing
the corresponding allocation problem can be easily seen to
be NP-hard. For this reason, we focus here on two important
classes of consumer valuation profiles.
• Unit-demand bidders: Each consumer would like to
buy at most one item, and is considering a number of
different options with different valuations for each. For
instance, the items may be houses, and the customer
may be willing to pay a higher price for some than for
others based on location, size, or other qualities.
• Single-minded (or single parameter) bidders: Each
consumer is interested only in one particular bundle.
He will buy the bundle if it is sufficiently cheap, and
otherwise not buy anything.
An interesting special case of these pricing problems
can be obtained by assuming that the items are available in
unlimited supply. In this special case, there is no limitation
on how many copies of each item are sold, and thus any
pricing is envy-free when the allocation is to give each
consumer their most preferred bundle. When we wish to
distinguish the unlimited supply case from the general case
we will refer to the general case as the limited supply case.
As we will show, both of these versions are not only
NP-complete, but APX-hard, even under strong additional
restrictions. We therefore focus on two kinds of results: (1)
approximation algorithms with logarithmic guarantees in the
general case, and (2) polynomial or pseudo-polynomial time
algorithms for interesting special cases.
We give an O(log n) approximation algorithm for the
limited supply unit demand problem, and an O(log n +
log m) approximation for the unlimited supply single-
minded bidder problem.
Furthermore, we define and give a polynomial time
algorithm for the unlimited supply pricing over time variant
of the unit demand problem. This problem models the case
where there is a single item for sale at various points in time
and each consumer wants to acquire the item within some
time interval (e.g., for bandwidth or airline tickets).
For the single-minded case, we define and investigate, in
Section 5.2, the Tollbooth problem on trees, and its special
case, the Highway problem on a path. In these problems,
consumers are interested in using a given path in the tree
(or on the path), and the seller can place toll booths on
the edges and charge prices for their usage. The additional
combinatorial structure provided by this restriction allows us
to give polynomial time algorithms for several cases of these
problems.
The envy-free pricing problem also has a role as a lower
bound in the setting of profit maximizing combinatorial auc-
tions. There, customers’ valuations are often not known, and
what is more, customers will choose to misrepresent their
valuations if they feel that they can get a better deal. Mech-
anism design studies the design of truthful (or incentive-
compatible) auctions which make it in the customers’ best
interest to disclose their true valuations. The performance of
such auctions is often measured in comparison to the profit
of the seller optimal envy-free pricings [13, 12],. In Section
4, we will investigate this connection further, and present a
log h-competitive truthful limited-supply unit-demand com-
binatorial auction for the case where all consumer valuations
are in the range [1, h]. We note that for any unlimited supply
combinatorial pricing problem (including the single-minded
case), a log h-competitive truthful mechanism is trivial.
Related Work. Pricing is a well-studied area in economics;
however, computational issues are not a major focus. Envy-
free pricing is part of a trend towards understanding the
algorithmic complexity of computing “equilibria”: in an
optimal envy-free pricing, the seller does not have any
incentive to change prices and the consumers do not have
any incentive to dispute the allocation. Examples of other,
somewhat different work in this category, can be found
in [9, 10].
As previously discussed, this work is related to truthful
auction design, and especially the design of truthful auctions
with worst-case performance guarantees, e.g., [12, 13, 11, 5,
4, 18].
Our interest here is in seller profit maximization. An-
other common goal for economically motivated algorithms
and mechanisms is that of economic efficiency: obtaining an
outcome which maximizes the sum of the utilities of all par-
ticipants. For the single-minded bidder case, when the goal
is efficiency, both the pricing problem and the mechanism
design problem have approximate solutions [19, 3]. For the
unit-demand case, the Vickrey-Clarke-Groves (VCG) mech-
anism [23, 8, 14] solves the problem in polynomial time (see
details in Section 4), and is both truthful and envy-free. We
note that computing the VCG mechanism is NP-hard for gen-
eral combinatorial auction problems including the special
case of single-minded bidders. The goal of economic effi-
ciency is quite different from maximizing the seller profit,
and there are simple examples where the VCG mechanism is
very far from maximizing the seller profit. For example, if
no two consumers want the same item then the VCG mech-
anism gives all items away for free!
For unit-demand envy-free pricing, a final, somewhat
informal connection is to the notion of stable matchings. By
introducing prices, we construct matchings of consumers to
items with the property that no consumer prefers the item
someone else gets to the item they get.
2 Preliminaries
We assume that there are n consumers, and a set J of m
distinct items. Each item j ∈ J exists in cj copies (we
explicitly allow cj = ∞), and we denote the supply vector
by c = (c1, . . . , cm). Each consumer has a valuation vi(S)
for each bundle S ⊆ J of items, which measures how
much receiving bundle S would be “worth” to consumer
i; we denote by V the n × 2J
matrix of valuations. For
convenience, we assume that vi(∅) = 0 for all consumers i.
Given a price vector p = (p1, . . . , pm), the utility that
consumer i derives from bundle S is Ui(S) = vi(S) − pS,
where pS =
P
j∈S pj; it measures the consumer’s “joy” at
having bought the bundle S at the given price. If consumer
i’s utility for the bundle S is non-negative, we call S feasible
for i.
User i’s demand set Di contains all bundles that would
make him maximally happy, i.e., all bundles that he would
most like to buy. Formally, Di = {S | Ui(S) =
maxS0 Ui(S0
)}. Since not buying any bundle is always an
option with utility Ui(∅) = 0, we have Ui(S) ≥ 0 for all
S ∈ Di.
Using this terminology, we can now define envy-free
pricing and allocations, the central notion of this paper.
DEFINITION 2.1.
1. An allocation (S1, . . . , Sn) of bundles to consumers is
feasible if each item j is in at most cj sets Si. Notice
that this may leave some items unallocated.
2. Given a pricing p = (p1, . . . , pm), an allocation
(S1, . . . , Sn) is envy-free if Si ∈ Di for all i, i.e., each
consumer receives a bundle from his demand set.
3. A pricing p is envy-free if it admits a feasible, envy-free
allocation.
Notice that if the supply is unlimited for all items, then
every price vector is envy-free, as we can select an arbitrary
bundle Si from each demand set Di, and obtain a feasible
allocation.
DEFINITION 2.2. The envy-free pricing problem: Given the
input (n, m, V, c), compute an envy-free pricing p and a
corresponding envy-free allocation (S1, . . . , Sn) maximizing
the seller profit
P
i pSi
.
When we talk about pricing algorithms for comput-
ing prices and allocations, we will often use the notation
Algo(V ) to denote both the output (p, (S1, . . . , Sn)) of the
algorithm and its revenue R =
P
i pSi
.
The most general case of the combinatorial envy-free
pricing problem is difficult for two reasons, (1) the mere
specification of V could be of size Ω(2m
) rendering the
problem intractable, and (2) even if V was a reasonable size,
the question of whether a given pricing is envy-free is NP-
hard to decide. Thus we are motivated to focus on more
tractable, yet important and rich subclasses of the problem.
The general version can be considered as an OR of ANDs:
the each user wants to buy one of several bundles, and buying
a bundle means buying all of its items. Two natural special
cases can be obtained by conceptually making the “fan-in”
of the AND/OR operators 1. Specifically, we then obtain:
• Unit-demand consumers: Each consumer is interested
in buying exactly one item, so vi(S) > 0 only when
|S| = 1. Thus, the size of the valuation matrix reduces
from n × 2m
to n × m, and the entry vi(j) denotes
consumer i’s valuation for item j. (This corresponds to
making the AND fan-in equal to 1.)
• Single-minded consumers: Each consumer i is inter-
ested in only one specific bundle of items Si. Thus,
the valuations V can be summarized by a set of pairs
(vi, Si) meaning that consumer i is interested in bundle
Si, and values it at vi. (This corresponds to making the
OR fan-in equal to 1.)
3 Pricing for Unit-Demand Consumers
In this section, we consider envy-free pricing in the unit-
demand setting.
3.1 APX-hardness. Even in a very restricted special case
of the unit-demand setting, finding optimal prices is APX-
hard, as stated by the following theorem. A similar result
was proven independently in [1].
THEOREM 3.1. The unit demand envy-free pricing problem
is APX-hard, even if each item exists in unlimited supply, and
each consumer has equal valuations (of either 1 or 2) for all
the items he has any interest in.
Proof. We give a reduction from the vertex cover problem
on graphs of maximum degree at most B for an absolute
constant B, which is known to be APX-hard (even for
B = 3). Given a graph G = (V, E) with n nodes (labeled
1, 2, . . . , n) and m edges (where m ≤ Bn/2 = O(n)), our
pricing instance has n items, one for each node of G, and
m + n consumers. (We assume G is connected w.l.o.g, so
m ≥ n − 1.) For each edge e = (i, j), there is a consumer
ce whose valuation for items i, j equals 1 and valuation for
all other items is 0. In addition, for each i = 1, 2, . . . , n,
there is a customer di whose valuation for item i equals 2,
and valuation for all other items equals 0.
We claim that the optimal pricing and corresponding
allocation of this instance achieves a total profit of m+2n−k
where k is the size of the smallest vertex cover of G. First,
if S is a vertex cover of G with |S| = k, consider the pricing
where items in S have cost 1, and those in V \ S have cost
2. Since each edge has at least one endpoint incident on a
node in S, we get profit 1 from each customer ce. Also,
for i /
∈ S, we get profit 2 from di, and for i ∈ S we
get profit 1 from di. Clearly, this yields a total profit of
m + 2(n − k) + k = m + 2n − k.
For the converse, first notice that each node/item is
without loss of generality priced at 1 or 2. If there exists
an edge e = (i, j) where both i, j are priced 2, then we are
making zero profit from ce. By reducing the price of say i to
1, we lose a profit of 1 from the customer di, but we make
up for it by making a profit of 1 from ce. Therefore, we may
assume that set of nodes priced at 1 forms a vertex cover of
G. This in turn implies that the profit is at most m + 2n − k
if k is the size of the smallest vertex cover.
Since m = Θ(n) and the minimum vertex cover has size
at least m/B = Ω(n), a constant factor gap in the size vertex
cover translates into a constant factor gap in the optimal
profit for the pricing instance, which yields the desired APX-
hardness result. 
3.2 A logarithmic approximation algorithm. In our fur-
ther discussion of the unit demand case, it will be help-
ful to think of allocations as matchings in bipartite graphs.
Specifically, given a price vector p, the demand graph is
a bipartite graph between consumers i and items j, dupli-
cated min(cj,n) times, containing an edge (i, j) if and only
if j ∈ Di. An envy-free matching is a matching M such that
each consumer i with ∅ /
∈ Di is matched. Then, the prices
p are envy-free if and only if the demand graph has an envy-
free matching, and the output of a pricing algorithm is the
pair (p, M).
To simplify the presentation, we assume that there is
exactly one copy of each item, i.e., cj = 1 for all items j.
For the unit-demand case, this assumption is without loss of
generality: if there are cj copies of an item, we can replace
them in the input by min(cj,n) distinct items, and give each
user the same valuation of all of those distinct items. The
envy-free condition then guarantees that all of these distinct
copies of an item will have the same price.
3.2.1 Walrasian Equilibria. Our approximation algo-
rithm builds on work in the economics literature concern-
ing Walrasian Equilibria [17]. Given a valuation matrix V , a
Walrasian Equilibrium (p, M) consists of an envy-free pric-
ing p and a matching M such that all unmatched items have
price zero. The following theorem, due to Gul and Stacchetti
[15], characterizes Walrasian Equilibria in the unit-demand
pricing problem.
THEOREM 3.2. [15] Let (p, M) be a Walrasian Equilib-
rium. Then M is a maximum weight matching on the val-
uation matrix V ; furthermore, for any maximum matching
M0
, (p, M0
) is also a Walrasian equilibrium.
For a valuation matrix V , we let ω(V ) denote the weight
of a maximum weight matching MM(V ). For an item j,
let V−j denote the valuation matrix with item j removed,
i.e., the matrix obtained by deleting column j from V . The
following algorithm finds the Walrasian Equilibrium with the
highest prices.
Algorithm MaxWEQ: Maximum Walrasian Prices.
Input: Valuation matrix V .
For each item j, let p̂j = ω(V ) − ω(V−j).
Output: p̂ and MM(V ).
THEOREM 3.3. [15] The algorithm MaxWEQ outputs, in
polynomial time, a Walrasian Equilibrium which maximizes
the item prices: if p is any Walrasian equilibrium, then
pj ≤ p̂j for every item j.
Note that the result [15] is based on the properties
of monotonicity and “single-improvement” of the utility
functions, properties which, as they mention, are obviously
satisfied in unit demand utility functions. [20] was the first
to define the prices given in Theorem 3.3 but did not argue
that they were maximum.
Unfortunately, even the Walrasian Equilibrium with the
highest prices can have revenue far from optimum. The
problem is that selling as many items as possible, a key
requirement of a Walrasian Equilibrium, may lead to very
low revenue.
Our algorithm will be following a common approach
to profit maximization in economics. We will augment
the computation of the Walrasian equilibrium with reserve
prices. A reserve price constrains the set of feasible pricings,
by requiring that item j be priced at least at rj. A classic
example of the use of reserve prices in economics is in the
Bayesian optimal auction [21, 7], where the reserve prices
are based on the known prior distribution from which the
consumers’ valuations are drawn.
DEFINITION 3.1. Given a valuation matrix V and a reserve
price vector r = (r1, . . . , rm), a Walrasian Equilibrium with
reserve prices r is an envy-free pricing p and allocation M
such that (1) pj ≥ rj for all j, (2) if item j is not sold, then
pj = rj, and (3) if item j is in the demand set of bidder i and
j is not sold, then bidder i is allocated an item.
Given an algorithm, Algo, to compute Walrasian Equi-
libria, we can use it to derive an algorithm, Algor, for com-
puting Walrasian Equilibria with reserve prices.
We augment the valuation matrix V to a new matrix V 0
by creating, for each item j, two dummy consumers, who
value item j at rj, and all other items at 0. Running Algo(V 0
)
then gives us a Walrasian Equilibrium (p, M0
). From M0
,
we deduce a matching by removing all dummy consumers
and their edges; finally, while there is an unsold item j in the
demand set of a real consumer i that is not allocated an item,
we allocate item j to consumer i. The resulting matching,
M, together with the prices, p, is the output of our algorithm
Algor(V ).
THEOREM 3.4. If Algo is an algorithm computing Wal-
rasian Equilibria, then Algor outputs a Walrasian Equilib-
rium with reserve prices r.
Proof. Consider (p, M0
). For each item j, at least one of
the two dummy customers is not allocated item j. Since that
customer is not envious, we must have pj ≥ rj.
Since (p, M0
) is envy-free, the output (p, M) must also
be envy-free for V : the prices have not changed.
Since (p, M0
) is a Walrasian Equilibrium, the only
unsold items in (p, M) are those that were allocated to
dummy consumers. This can only happen if pj ≤ rj, hence
pj = rj.
The last step of the algorithm only comes up for cus-
tomers whose bundles in their demand set all have utility 0,
and ensures that condition (3) is satisfied. 
Our algorithm will compute Walrasian Equilibria for
several appropriately chosen reserve prices, and output the
one yielding maximum revenue among them. The analysis
will be based on the following lemma.
LEMMA 3.1. Let π be a maximum weighted matching on the
valuation matrix V . Given a value r, let kr be the number
of edges of π with valuation at least r. If (p, M) is any
Walrasian Equilibrium with reserve prices r = (r, r, . . . , r),
then the seller profit of (p, M) is at least r · kr/2.
Proof. Consider an edge (i, j) of π with valuation at least r.
From the definition of a Walrasian equilibrium with reserve
prices, we obtain that if item j is not matched by M, then
pj = r; if in addition j ∈ Di then customer i must be
matched by M, whereas if j /
∈ Di then the bundles in the
demand set of i all have positive valuation and so customer i
must also be matched by M. Thus, for every edge (i, j) of π
with valuation at least r, we have that either i or j is matched
in M.
Summing over edges of π with valuation at least r, we
get that kr ≤ 2|M|, and so M sells items, all at price at least
r, to at least kr/2 consumers, yielding seller profit at least
r · kr/2. 
3.2.2 The Envy-free Approximation Algorithm. Using
the algorithm MaxWEQr, obtained by modifying the al-
gorithm for maximum Walrasian prices to include reserve
prices, we can now give our approximation algorithm.
Envy-Free Pricing Approximation Algorithm
Input: Valuation matrix V .
1. Let π be a maximum weight matching of V , and
r1 ≥ r2 ≥ . . . ≥ r` the valuations on the edges of
π.
2. For each j, run the algorithm MaxWEQr on input
V , with reserve prices r = (rj, rj, . . . , rj). Let
(p(j)
, M(j)
) be the output.
Output: The pair (p(j∗
)
, M(j∗
)
) with the maximum seller
profit.
THEOREM 3.5. The Envy-free Pricing Approximation Al-
gorithm outputs, in polynomial time, an envy-free pricing
and matching which has seller profit at least OPT /(2 ln n),
where OPT is the optimal envy-free seller profit.
Proof. The output is envy-free by Theorem 3.4, and the
running time is clearly polynomial.
Let P denote the profit of our approximation algorithm.
For all j we have
P ≥ Profit(p(j)
, M(j)
) ≥
j · rj
2
by Lemma 3.1, and so rj ≤ 2P/j.
On the other hand, the optimal envy-free seller profit is
at most the weight of the maximum weighted matching π,
i.e.,
OPT ≤
X
j
rj ≤
X
j
2P
j
≤ 2P ln n. 
Notice that we only used the fact that the (p(j)
, M(j)
)
are Walrasian Equilibria with reserve prices, but did not re-
quire the maximality of the Walrasian Equilibria found by
MaxWEQ. Hence, we could have used any algorithm Algor
for computing Walrasian Equilibria with reserve prices in-
stead.
The analysis of the algorithm is tight: Consider an
instance with n consumers and two copies of each of n items,
where consumer i values all items j ≥ i at 1/i, and all other
items at 0. Then, pricing item j at 1/j, and allocating it
to consumer j, is envy-free and has profit Θ(ln n), while
our algorithm obtains profit 1. The algorithm’s profit is 1
because no duplicate copies are sold; hence, all items must
be priced at the reserve price.
3.3 Pricing Over Time. We now consider a special case
of unit-demand envy-free pricing, the pricing over time
problem, where the different items represent one object that
is available at different points in time (for instance, an airline
ticket or network bandwidth). Here, each consumer i values
the item at a constant value of vi over a time interval [si, ti]
and at 0 at all other times. The envy-free condition means
that customer i will buy the item at the lowest price below
vi that is available during the [si, ti] interval. The unlimited
supply case of pricing over time may be a good model for
selling digital content. Blum et al. [6] previously considered
a similar pricing over time model; however, the problem they
considered was online and did not require the pricing to be
envy-free.
THEOREM 3.6. The Unlimited-Supply Pricing Over Time
problem can be solved in polynomial time.
Proof. Although the definition of the problem is in a contin-
uous time setting, one only needs to check envy-freeness at
times which are in the set ∪i{si, ti}, so that there are at most
2n distinct times to consider, and this reduces the problem
to a discrete time setting. We now give a dynamic program-
ming algorithm. For points in time s < t, and a price p,
we define ap(s, t) to be the maximum profit that can be ob-
tained from consumers i with s < si and ti < t, when the
minimum price over the time interval (s, t) is at least p. We
are then interested in computing a0(0, ∞).
The trivial base case occurs when no consumer would
pay at least p in the interval (s, t), and the profit is 0.
Otherwise, given s and t, and using nt0,q to denote the
number of consumers i (among those with s < si and
ti < t) who would be willing to buy the item at price q at
time t0
(i.e., si ≤ t0
≤ ti and vi ≥ q), we can express
ap(s, t) = maxq≥p,t0∈(s,t)(aq(s, t0
) + aq(t0
, t) + q · nt0,q).
Any particular choice of q and t0
corresponds to selling
the item at price q at time t0
, to all consumers willing to buy
it then. To ensure envy-freeness, this imposes a constraint
of pricing at least at q during the sub-intervals that these
consumers would also be willing to buy at.
The optimality of the dynamic program follows simply
by looking at the selling times and prices of the optimum
solution in non-decreasing order of price. The crucial obser-
vation is that we only need to consider a polynomial num-
ber of prices q and times t0
. For the latter, we notice that
items only need to be sold at times si or ti, i.e., endpoints of
consumers’ intervals. Any other selling time can be shifted
slightly to the left or right without altering profit. Similarly,
all selling prices are valuations vi: if the item were ever sold
at a price p not equal to a valuation, then all prices of p could
be raised slightly without losing customers or creating envy.
Hence, the dynamic programming table contains only O(n3
)
entries ap(s, t), each of which is computed in time O(n2
).
This completes the proof. 
We can extend this approach to a pseudo-polynomial
time algorithm for limited supply ct at time t. Given s and t,
let n+
t0,q denote the number of customers with si ≤ t0
≤ ti
and with valuation at t0
strictly greater than q. Then the
dynamic program relies on the following recurrence relation:
ap(s, t) = max
q≥p,t0∈(s,t)
of



(aq(s, t0
) + aq(t0
, t) + q · nt0,q). if nt0,q ≤ ct0
(aq(s, t0
) + aq(t0
, t) + q · ct0 ). if n+
t0,q ≤ ct0 ≤ nt0,q
−∞ if ct0 < n+
t0,q
Whether the problem can also be solved in polynomial
time in the presence of limited supply is an open question.
The best-known approximation algorithm is the general log-
arithmic approximation from the previous section; however,
we do not know the limited supply problem to be NP-hard.
4 Towards Truthful Competitive Mechanisms
As discussed in the introduction, an additional motivation
for the study of envy-free pricing is the fact that the profit
obtainable from such a pricing is a natural lower bound to
analyze truthful mechanisms for profit maximizing combina-
torial auctions. In a combinatorial auction, the setting is the
same as before, except that the valuations vi(S) are known
only to consumer i, but not the seller. The seller solicits,
implicitly or explicitly, the valuations from the consumers
in the process of running an auction. The consumers, who
know the auction mechanism, will choose to misrepresent
their valuations if they derive more utility from the result-
ing outcome. A popular approach to dealing with this kind
of strategizing is to design truthful mechanisms, in which it
is in the consumers’ own best interest to disclose their true
valuations.
In analyzing the performance of a mechanism, it is
natural to compare it with an optimal omniscient seller via
a competitive analysis [13, 11, 5]. If the seller is allowed to
sell identical items to different consumers at different prices,
then no truthful mechanism can be competitive [13]. Thus,
[13, 11, 5] consider the optimal omniscient seller that uses
a single price for identical items. The natural generalization
of the single-price condition to the case where distinct items
are for sale is that of envy-freeness.
Building on the ideas used in the approximation al-
gorithm in Section 3.2, we present a new truthful log h-
competitive mechanism mechanism for unit-demand combi-
natorial auctions when all valuations are in the interval [1, h].
That is, the mechanism is guaranteed to achieve at least a
1/ log h fraction of the optimal envy-free pricing profit.
Our mechanism builds on the Vickrey-Clarke-Groves
(VCG) mechanism with reserve prices. The VCG mech-
anism, much like Walrasian Equilibria, outputs the effi-
cient allocation given by the maximum weighted match-
ing, M. However, the VCG mechanism aims at achieving
truthfulness, and therefore computes prices different from
MaxWEQ. If V−i denotes the matrix of valuations with the
ith
row (corresponding to the consumer i) deleted, the pay-
ment of consumer i, and thus the price of the item j allocated
to consumer i by M, is computed as:
pj = vi(j) − ω(V ) + ω(V−i),
where ω(V ) again denotes the weight of a maximum match-
ing of the valuation matrix V .
VCG is known to be truthful; interestingly, its prices
are exactly the minimum Walrasian prices [20], and thus the
VCG prices are in fact envy-free. Since VCG computes a
Walrasian Equilibrium, we can use the generic technique
presented in Section 3.2.1 to obtain the VCG mechanism
with reserve prices, VCGr; the correctness of the mecha-
nism follows from Theorem 3.4. The construction of adding
reserve prices to VCG is well known, and the resulting mech-
anism VCGr is truthful [23, 8, 14].
We can use this fact to obtain a truthful log h-
competitive auction, in a manner similar to the envy-free
pricing approximation algorithm. However, to preserve
truthfulness, we cannot run VCGr for different choices of
reserve prices; instead, we will choose the reserve price ran-
domly. The complete mechanism is then:
Unit Demand Combinatorial Auction Input: Valuation
matrix V , where 1 ≤ vi(j) ≤ h for all i, j.
1. Pick an integer k uniformly at random from
{1, . . . , blog hc}, and let r = 2k
.
2. Compute prices p and an allocation M by running
the algorithm VCGr on input V with reserve prices
r = (r, r, . . . , r).
Output: the pair (p, M).
THEOREM 4.1. The unit-demand combinatorial auction is
truthful and 4 log h competitive for any input in which all
consumer valuations are in the interval [1, h].
Proof. That the auction is truthful follows directly from the
truthfulness of VCGr.
Let r1 ≥ r2 ≥ . . . ≥ rm be the prices of the items
sold in the maximum weighted matching M. Clearly, the
optimum profit is bounded from above by
P
j rj. Let nr be
the number of items sold in M at price r or more (i.e., nr is
the index j such that rj ≥ r > rj+1). If r = (r, r, . . . , r),
then Lemma 3.1 implies that the revenue of VCGr is at least
r · nr/2, so the expected revenue R of the auction is at least
P
k=0 blog hc
2k
n2k
2 log h .
On the other hand, we can bound each price rj as
rj ≤ 2
Pblog hc
k=0 2k
· [rj ≥ 2k
], where [rj ≥ 2k
] is 1 if
rj ≥ 2k
and 0 otherwise. Summing over all j, we obtain that
P
j rj ≤ 2
Pblog hc
k=0 2k
· n2k ≤ (4 log h) · R,
completing the proof. 
Note that if h is polynomial in n, this auction has the
same approximation ratio as the non-truthful approximate
envy-free pricing algorithm given earlier. However, there
are instances where the latter algorithm outperforms this
mechanism by a factor of log n, e.g., when using a single
price is close to optimal.
5 Single-Minded Consumers
We now turn to the problem of envy-free pricing for single-
minded consumers. Recall that the input in this case is
given by the pairs (vi, Si): consumer i values the bundle
Si at vi, and all other bundles at 0. We will also refer to
Si as consumer i’s request, and vi as his bid. Even under
strong additional restrictions, the pricing problem for single-
minded consumers is APX-hard, as shown below.
THEOREM 5.1. Envy-free pricing for single-minded con-
sumers is APX-hard, even when all items are available in
unlimited supply, and
1. vi = 1 and |Si| ≤ 2 for all i, or
2. vi ∈ {1, 2}, and |Si| = 2, for all i.
Proof. We first show that the problem is APX-hard when
vi = 1 for all requests i and |Si| ≤ 2 for all i by a reduction
from the MAXCUT problem for 3-regular graphs (which was
shown to be APX-hard in [2]). Let G = (V, E) be the
instance of MAXCUT (a 3-regular graph), with n = |V |
nodes and m = |E| edges.
The items consist of an element v for each node v ∈ V ,
as well as a positive dummy dp and a negative dummy dn.
All consumer valuations are equal to 1, and requests fall
into three classes: edge requests, node requests, and dummy
requests. The edge requests are simply one request for each
edge e = {u, v} ∈ E. The node requests are 4 requests
each for the sets {dp, v} and {dn, v}, for each node v. The
dummy requests are 5m requests for the set {dp}, and 5m
requests for the set {dp, dn}.
We show that there is a price vector with profit at least
10m + 4n + k if and only if there is a cut that cuts at least k
edges.
For the easy direction, assume that there is a cut cutting
at least k edges. Assign price 1 to dp and to all nodes on one
side of the cut, and price 0 to dn and to all other nodes. We
can then verify that the profit is at least 10m + 4n + k.
For the converse direction, let p be a price vector with
maximum profit, and assume that the profit is at least 10m +
4n + k. By simple exchange arguments, we can first show
that the optimality implies that pdp
= 1, and pdn
= 0. Using
this, we can next use exchange arguments to show that each
pv is either 0 or 1, by first ruling out that any pv is between
0 and 1
2 , and then rounding all non-zero prices to 1.
The price vector then defines a natural cut between
nodes of price 0 and nodes of price 1. Because the total
revenue from dummy requests is exactly 10m, and from
node requests 4n, the total profit from edge requests must
be k; and it can be seen easily that an edge contributes profit
1 if and only if it is cut.
Because the maximum cut cuts at least half of the edges,
we are only interested in the case where k ≥ m/2, and
because the graph is 3-regular, we also have n ≤ m.
Then, a few straightforward calculations show that a 28+α
29
approximation for the envy-free pricing problem would yield
an α-approximation to cubic MAXCUT, proving that the
envy-free pricing problem is NP-hard to approximate within
28+α
29 , where α is the approximation hardness constant in [2]
(not given explicitly there).
The above reduction can be adapted very slightly to
yield the same result when all set sizes are exactly 2, and
all valuations are either 1 or 2. To avoid the single element
requests {dp}, we add one more dummy element d, and
replace the requests {dp} with 5m requests for the set
{d, dp} with valuation 2 each, and 5m requests for the set
{d, dn} with valuation 1 each.
Now, a very similar argument can be used to show that
in an optimal solution, the prices are pd = pdp
= 1, and
pdn
= 0; the remainder of the proof stays unchanged. 
5.1 A Logarithmic Approximation Algorithm for Items
in Unlimited Supply. The previous hardness result shows
that we are unlikely to find a PTAS for the single-minded
bidder case. However, it is fairly straightforward to get a
logarithmic approximation for single-minded bidders in the
case of unlimited supply. Our algorithm only considers pric-
ings in which all items are priced the same. The candidate
prices are qi = vi/|Si|, for each customer i. Among the
pricings assigning all items price qi, our algorithm simply
selects the one giving largest profit and outputs it.
THEOREM 5.2. This algorithm is a log n + log m approxi-
mation for envy-free pricing when bidders are single-minded
and items are available in unlimited supply.
Proof. We assume that the consumers are ordered such that
q1 ≥ q2 ≥ . . . ≥ qn. If all items are priced at qi, then
the seller profit is Ri =
P
1≤j≤i |Sj| · vi/|Si|. Rearranging
yields that vi = |Si|Ri/
P
1≤j≤i |Sj|. Because the algorithm
chooses the price R maximizing profit, we have that Ri ≤ R
for all i, and thus
n
X
i=1
vi =
n
X
i=1
|Si|Ri
P
1≤j≤i |Sj|
≤ R ·
n
X
i=1
|Si|
X
k=1
1
k +
P
1≤j≤i−1 |Sj|
≤ R · ln(
X
i
|Si|).
P
i vi is a trivial upper bound on the optimum, so the
theorem follows because
P
i |Si| ≤ nm. 
The analysis of this algorithm is tight, as can be seen
by the example in which customer i wants to buy only
item i, with valuation 1/i. In this case, the trivial upper
bound is easily achievable, while our algorithm only has
revenue 1. On the other hand, any analysis using only this
trivial upper bound on the optimal revenue cannot prove an
approximation guarantee better than O(log n), as can be seen
by the simple example of all users requesting item 1, with
user i’s valuation being 1/i.
5.2 The Tollbooth Problem. While the envy-free pricing
problem, even for single-minded bidders, is hard to approx-
imate, there are interesting and more tractable special cases.
Here, we study the tollbooth problem. The items are now
the edges of a graph G, which we may think of as high-
way segments, and customers’ requests are for paths in the
graph. A customer’s valuation may be derived from the price
in money and inconvenience of using an alternate method of
transportation. The seller is the owner of the highway sys-
tem, and would like to choose tolls for the segments so as to
maximize profits. Notice that the APX-hardness reduction
in Theorem 5.1 can be thought of as generating length-1 or
length-2 paths in a star graph, so the tollbooth problem on
trees is still APX-hard.
A special case that is polynomial-time solvable is the
case when all path requests share one common endpoint
r, which we consider as the root of the tree. This case
is motivated by commuter traffic in the vicinity of a large
city: most cars are either originating from or destined for the
large city, and the paths used by most of the cars forms a
tree. We first assume that edges have infinite capacity, which
corresponds to unlimited supply.
THEOREM 5.3. The unlimited supply tollbooth problem on
rooted trees can be solved in polynomial time.
Proof Sketch. We give a dynamic programming algorithm.
For a node w, let Rw denote the set of all requests originating
in the subtree Tw rooted at w. We define a(w, b) to be the
optimum revenue obtainable from requests in Rw if the path
from w to the root costs exactly b. We are then interested in
computing a(r, 0).
For node w, let w1, . . . , wk denote its children, and
nw(b) the number of requests originating at w with valuation
b or higher. Then:
a(w, b) = b · nw(b) +
P
i maxb0≥b a(wi, b0
).
The crucial observation is that we only need to consider
a polynomial number of costs b. Indeed, all selling path
prices are valuations: if there is a feasible request (w, b) ∈
Rw in the optimum pricing, then w.l.o.g., the total price of
the path from w to the root is b0
, for some (w0
, b0
) ∈ Rw.
This claim is easily proved by induction, starting at the leaves
of the tree.
Hence in the maximum over b0
≥ b, we only have to
consider values b0
∈ Rwi
, so the dynamic programming table
has size O(n2
), and a(w, b) can be computed in polynomial
time.
We can extend the previous approach to obtain a pseudo-
polynomial time dynamic programming algorithm for the
case of edge capacities ce. We let a(w, c, b) denote the
maximum revenue that can be obtained if at most c requests
from Rw are feasible, and the path from w to the root has
total price exactly b. Here, we write n+
w(b) for the number
of requests originating with node w with valuation strictly
greater than b. When, writing ei for the edge from w to its
child wi, the envy-freeness condition implies that we can
compute a(w, c, b) as the maximum, over (c0, c1, . . . , ck)
such that 0 ≤ ci ≤ cei
, n+
w(b) ≤ c0 ≤ nw(b), and
P
i ci ≤ c, of
(b · c0 +
X
i≥1
max
b0≥b
a(wi, ci, b0
)).
Here, c0 is the capacity allotted to requests originating
with w, and the envy-freeness condition requires all requests
with valuation strictly exceeding b to be served. While the
maximum is seemingly taken over
Q
i cei
k-tuples, it can in
turn be computed by dynamic programming over values of
cj vs.
P
j0>j cj0 .
5.3 The Highway Problem. Another “simple” case of the
tollbooth problem is when the underlying graph is in fact a
path, and all requests are subpaths (not necessarily sharing
a common endpoint). This case is clearly motivated by
tolls to be charged on a single freeway. Even though a
path is about as simple a graph as we can hope for, the
problem is surprisingly complex: at this point, we do not
know if optimal prices can be computed in polynomial time,
or whether the problem is NP-hard on a path. However,
we can derive pseudo-polynomial dynamic programming
algorithms when some of the parameters are bounded. Here
again we assume infinite edge capacity. The algorithms rely
on the following integrality lemma:
LEMMA 5.1. If all valuations vi are integral, then there is
an optimal solution in which all prices pe are integral.
Proof. Let p be any price vector, and R the set of all
requests feasible under p. We show that there is an integral
assignment p0
such that each request in R is still feasible
under p0
, and the total profit obtained from R is at least as
large as under p. Applying this to the optimal assignment p
then clearly proves the lemma.
Each request is a subpath, so if the edges are numbered
1, . . . , m, with prices p1, . . . , pm, then each request i uses
some edges li, . . . , ri. Given the set R of requests that
must be feasible, the optimal assignment that makes all of
R feasible is the solution to the following linear program:
Maximize
P
i∈R
Pri
j=li
pj
subject to
Pri
j=li
pj ≤ vi for each i ∈ R
pj ≥ 0 for each j
Notice that each row in the matrix for the LP is of the
form 0∗
1∗
0∗
. This is enough to prove that the matrix is
totally unimodular, i.e., that the determinant of each non-
singular square submatrix is ±1. Indeed, consider any
submatrix. It still satisfies the property that each row is of the
form 0∗
1∗
0∗
. To compute the determinant, reorder the rows
by non-decreasing li, then by non-decreasing ri, subtract the
first row from every row which starts with a 1. These steps
do not change the determinant except for perhaps its sign,
and we are now left with a matrix whose first column has
a 1 at the first row and 0’s everywhere else, and every row
is of the form 0∗
1∗
0∗
. Expanding by the first column, we
conclude unimodularity by induction. Because the matrix
is totally unimodular, we can apply a theorem of Hoffman
and Kruskal [16, 22], which states that for an integral right-
hand side vector V = (vi), all vertex solutions of the LP are
integral. In particular, as there is an optimal solution that is
a vertex, we obtain that there is an integer optimum, which
completes the proof. 
We can use the integrality lemma to obtain a pseudo-
polynomial time dynamic programming algorithm for the
following special cases.
THEOREM 5.4. 1. If there is a constant upper bound B
on all valuations vi, and all valuations are integral,
then there is a polynomial-time (O(BB+2
nB+3
)) dy-
namic programming algorithm to find an optimal price
vector.
2. If all requests have path lengths bounded by some con-
stant k, and all valuations are integral, then there is
a pseudo-polynomial dynamic programming algorithm
with running time O(Bk+1
· n) for computing an opti-
mal price vector.
Proof Sketch. We sketch dynamic programs with an analy-
sis for both restrictions. Details of the analysis will be given
in the full version.
1. Our dynamic programming algorithm maintains a table
with entries aj,(k1,γ1),...,(kB+1,γB+1), which denotes the max-
imum profit that can be obtained from requests i with right
endpoint ri ≤ j, given that the rightmost B + 1 edges with
non-zero price to the left of j are k1 < k2 < . . . < kB+1 ≤ j
with associated prices γ1, . . . , γB+1 > 0. A crucial obser-
vation here is that the above integrality lemma (Lemma 5.1)
guarantees that we need only consider γb ∈ {1, . . . , B}, and
thus also
PB+1
b=1 γb > B. This in turn implies that no request
i with li < k1 and ri ≥ kB+1 can be feasible, so we can
safely ignore these requests.
The initialization for the table is fairly clear. For
the update step, consider the pricing of the edge j + 1,
starting from a table entry a = aj,(k1,γ1),...,(kB+1,γB+1).
If edge j + 1 is priced at 0, then we add to a the profit
obtained from paths ending at j + 1 to obtain a candidate
for aj+1,(k1,γ1),...,(kB+1,γB+1). Otherwise, when edge j + 1
is given a positive price γ, we obtain a candidate for table
entry aj+1,(k2,γ2),...,(kB+1,γB+1),(j+1,γ), again by adding to
a the profit obtained from paths ending at j + 1.
It is not difficult to see that we can conversely
reconstruct all O(nB) candidate table entries that
could result in candidates for a particular desired entry
aj+1,(k1,γ1),...,(kB+1,γB+1), and then choose the maximum
among all those candidates. Hence, the total running time
(with O(BB+1
nB+2
) table entries) is O(BB+2
nB+3
).
2. The algorithm maintains a table aj,γ1,...,γk
, where an entry
is the maximum amount of profit that can be obtained from
requests ending at position j or below, given that the edges
j, j − 1, . . . , j − k + 1 are priced at γ1, . . . , γk, respectively.
To calculate an entry aj+1,γ1,...,γk
, consider all possible
values of γ0
∈ {0, . . . , B}, and add to aj+1,γ2,...,γk,γ0 the
maximum profit for all feasible requests ending exactly at
j + 1 with cost assignments γ2, . . . , γk, γ0
to edges j, j −
1, . . . , j + 2 − k, j + 1 − k. Because no path has length
exceeding k, the values of (γi)i and γ0
are sufficient to
determine whether a request is feasible, and we can restrict
the choices of γ0
to {0, . . . , B} because of the Integrality
Lemma 5.1.
The computation of a new table entry takes time O(B),
and because the table size is O(Bk
n), the running time is
O(Bk+1
n).
6 Some open questions
There are a number of open problems left in this paper.
For the single parameter limited supply case, is there a
sublinear factor polynomial time approximation algorithm?
For the unit demand case, is there a sublogarithmic factor
approximation algorithm? As of yet we do not have a good
understanding of how different prices interact. Note that our
hardness result for the unit demand case only requires two
different price levels. Note that if there are only two price
levels then there is a trivial 2-approximation to the optimal
unlimited supply envy-free pricing.
References
[1] G. Aggarwal, T. Feder, R. Motwani, and A. Zhu. Algorithms
for multi-product pricing. In Proc. of ICALP, 2004.
[2] P. Alimonti and V. Kann. Hardness of approximating prob-
lems on cubic graphs. In Proc. 3rd Ital. Conf. on Algorithms
and Complexity, pages 288–298. Springer, 1997.
[3] A. Archer, C. Papadimitriou, K. Talwar, and E. Tardos. An
approximate truthful mechanism for combinatorial auctions
with single parameter agents. In Proc. 14th ACM Symp. on
Discrete Algorithms. ACM/SIAM, 2003.
[4] A. Archer and E. Tardos. Frugal path mechanisms. In Proc.
13th ACM Symp. on Discrete Algorithms, pages 991–999.
ACM/SIAM, 2002.
[5] A. Blum, V. Kumar, A. Rudra, and F. Wu. Online learning
in online auctions. In Proc. 14th ACM Symp. on Discrete
Algorithms. ACM/SIAM, 2003.
[6] A. Blum, T. Sandholm, and M. Zinkevich. Online algorithms
for market clearing. In Proc. 13th ACM Symp. on Discrete
Algorithms, pages 971–980. ACM/SIAM, 2002.
[7] J. Bulow and J. Roberts. The simple economics of optimal
auctions. The Journal of Political Economy, 97:1060–90,
1989.
[8] E. H. Clarke. Multipart pricing of public goods. Public
Choice, 11:17–33, 1971.
[9] X. Deng, C. Papadimitriou, and M. Safra. On the complexity
of equilibria. In Proc. 34th ACM Symp. on Theory of
Computing. ACM Press, 2002.
[10] N. Devanur, C. Papadimitriou, A. Saberi, and V. Vazirani.
Market equilibria via primal-dual-type algorithm. In Proc.
43rd IEEE Symp. on Foundations of Computer Science, 2002.
[11] A. Fiat, A. Goldberg, J. Hartline, and A. Karlin. Competitive
generalized auctions. In Proc. 34th ACM Symp. on Theory of
Computing. ACM Press, 2002.
[12] A. Goldberg and J. Hartline. Competitive auctions for multi-
ple digital goods. In Proc. 9th European Symposium on Algo-
rithms, pages 416–427. Springer, 2001.
[13] A. V. Goldberg, J. D. Hartline, and A. Wright. Competitive
auctions and digital goods. In Proc. 12th ACM Symp. on
Discrete Algorithms, pages 735–744. ACM/SIAM, 2001.
[14] T. Groves. Incentives in teams. Econometrica, 41:617–631,
1973.
[15] F. Gul and E. Stacchetti. Walrasian equilibrium with gross
substitutes. Journal of Economic Theory, 87:95–124, 1999.
[16] A. Hoffman and J. Kruskal. Integral boundary points of
convex polyhedra. In H. Kuhn and A. Tucker, editors, Linear
Inequalities and Related Systems, pages 223–246. Princeton
University Press, 1956.
[17] T. Koopmans and M. Beckmann. Assignment problems and
the location of economic activities. Econometrica, 25:53–76,
1957.
[18] R. Lavi, A. Mu’alem, and N. Nisan. Towards a characteriza-
tion of truthful combinatorial auctions. In Proc. 44th IEEE
Symp. on Foundations of Computer Science, 2003.
[19] D. Lehmann, L. I. O’Callaghan, and Y. Shoham. Truth
revelation in approximately efficient combinatorial auctions.
In Proc. 1st ACM Conf. on Electronic Commerce, pages 96–
102. ACM Press, 1999.
[20] H. Leonard. Elicitation of honest preferences for the assign-
ment of individuals to positions. Journal of Political Econ-
omy, 91:1–36, 1983.
[21] R. Myerson. Optimal auction design. Mathematics of
Operations Research, 6:58–73, 1981.
[22] C. Papadimitriou and K. Steiglitz. Combinatorial Optimiza-
tion. Dover, 1982.
[23] W. Vickrey. Counterspeculation, auctions, and competitive
sealed tenders. J. of Finance, 16:8–37, 1961.
[24] L. Walras. Elements of Pure Economics. Allen and Unwin,
1954.
