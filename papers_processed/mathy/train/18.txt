Fairness in Learning: Classic and Contextual Banditsâˆ—
Matthew Joseph Michael Kearns Jamie Morgenstern Aaron Rothâ€ 
November 8, 2016
Abstract
We introduce the study of fairness in multi-armed bandit problems. Our fairness definition
can be interpreted as demanding that given a pool of applicants (say, for college admission or
mortgages), a worse applicant is never favored over a better one, despite a learning algorithmâ€™s
uncertainty over the true payoffs. We prove results of two types:
First, in the important special case of the classic stochastic bandits problem (i.e. in which
there are no contexts), we provide a provably fair algorithm based on chained confidence inter-
vals, and prove a cumulative regret bound with a cubic dependence on the number of arms. We
further show that any fair algorithm must have such a dependence. When combined with regret
bounds for standard non-fair algorithms such as UCB, this proves a strong separation between
fair and unfair learning, which extends to the general contextual case.
In the general contextual case, we prove a tight connection between fairness and the KWIK
(Knows What It Knows) learning model: a KWIK algorithm for a class of functions can be
transformed into a provably fair contextual bandit algorithm, and conversely any fair contextual
bandit algorithm can be transformed into a KWIK learning algorithm. This tight connection
allows us to provide a provably fair algorithm for the linear contextual bandit problem with
a polynomial dependence on the dimension, and to show (for a different class of functions) a
worst-case exponential gap in regret between fair and non-fair learning algorithms.
âˆ—
A condensed version of this work appears in the 30th Annual Conference on Neural Information Processing
Systems (NIPS), 2016.
â€ 
Department of Computer and Information Sciences, University of Pennsylvania.
{majos,mkearns,jamiemor,aaroth}@cis.upenn.edu. AR is supported in part by an NSF CAREER award, a
Sloan Foundation Fellowship, and a Google Faculty Research Award.
1
arXiv:1605.07139v2
[cs.LG]
7
Nov
2016
Contents
1 Introduction 3
1.1 Fairness and Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.2 Our Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.3 Other Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2 Preliminaries 6
2.1 Specializing to Classic Stochastic Bandits . . . . . . . . . . . . . . . . . . . . . . . . 7
3 Fair Classic Stochastic Bandits: An Algorithm 8
4 Fair Classic Stochastic Bandits: A Lower Bound 11
5 KWIK Learnability Implies Fair Bandit Learnability 15
6 Fair Bandit Learnability Implies KWIK Learnability 18
6.1 An Exponential Separation Between Fair and Unfair Learning . . . . . . . . . . . . . 20
A Missing Proofs for the Classic Stochastic Bandits Upper Bound 23
A.1 Missing Derivation of R(T) for Theorem 2 . . . . . . . . . . . . . . . . . . . . . . . . 24
B Missing Proofs for the Classic Stochastic Bandits Lower Bound 24
C Missing Proofs for the Contextual Bandit Setting 26
2
1 Introduction
Automated techniques from statistics and machine learning are increasingly being used to make
decisions that have important consequences on peopleâ€™s lives, including hiring [Miller, 2015], lending
[Byrnes, 2016], policing [Rudin, 2013], and even criminal sentencing [Barry-Jester et al., 2015].
These high stakes uses of machine learning have led to increasing concern in law and policy circles
about the potential for (often opaque) machine learning techniques to be discriminatory or unfair
[Coglianese and Lehr, 2016, Barocas and Selbst, 2016]. Moreover, these concerns are not merely
hypothetical: Sweeney [2013] observed that contextual ads for public record services shown in
response to Google searches for stereotypically African American names were more likely to contain
text referring to arrest records, compared to comparable ads shown in response to searches for
stereotypically Caucasian names, which showed more neutral text. She confirmed that this was
not because of stated preferences of the advertisers, but rather the automated outcome of Googleâ€™s
targeting algorithms. Despite the recognized importance of this problem, very little is known about
technical solutions to the problem of â€œunfairnessâ€, or the extent to which â€œfairnessâ€ is in conflict
with the goals of learning.1
In this paper, we consider the extent to which a natural fairness notion is compatible with
learning in a general setting (the contextual bandit setting), which can be used to model many of
the applications mentioned above in which machine learning is currently employed. In this model,
the learner is a sequential decision maker, which must choose at each time step t which decision
to make, out of a finite set of k choices (for example, which of k loan applicants â€“ potentially from
different populations or racial groups â€“ to give a loan to). Before the learner makes its decision
at round t, it observes some context xt
j for each choice of arm j (xt
j could, for example, represent
the contents of the loan application of an individual from population j at round t). When the
learner chooses arm j at time t, it obtains a stochastic reward rt
j whose expectation is determined
by some unknown function of the context: E
h
rt
j
i
= fj(xt
j). The goal of the learning algorithm is
to maximize its expected reward â€“ i.e. to approximate the optimal policy, which at each round,
chooses arm j to maximize E
h
rt
j
i
. The difficulty in this task stems from the unknown functions
fj which map contexts to rewards; these functions must be learned. Despite this, there are many
known algorithms for learning the optimal policy (in the absence of any fairness constraint).
1.1 Fairness and Learning
Our notion of individual fairness is very simple: it states that it is unfair to preferentially choose
one individual (e.g. for a loan, a job, admission to college, etc.) over another if he or she is
not as qualified as the other individual. This definition of fairness is apt for our setting, since in
contextual learning, the quality of an arm is clear: its expected reward. We view different arms
1
For example, a 2014 White House report [Podesta et al., 2014] notes that â€œ[t]he increasing use of algorithms
to make eligibility decisions must be carefully monitored for potential discriminatory outcomes for disadvantaged
groups, even absent discriminatory intent. . . additional research in measuring adverse outcomes due to the use of
scores or algorithms is needed to understand the impacts these tools are having and will have in both the private and
public sector as their use grows.â€ Along the same lines, a 2016 White House report [Munoz et al., 2016] observes that
â€œ[a]s improvements in the uses of big data and machine learning continue, it will remain important not to place too
much reliance on these new systems without questioning and continuously testing the inputs and mechanics behind
them and the results they produce.â€ Similarly, in a recent speech FTC Commissioner Julie Brill [Julie Brill, 2015]
observed, â€œ. . . a lot remains unknown about how big data-driven decisions may or may not use factors that are proxies
for race, sex, or other traits that U.S. laws generally prohibit from being used in a wide range of commercial decisions
. . . What can be done to make sure these products and servicesâ€“and the companies that use them treat consumers
fairly and ethically?â€
3
j as representing different populations (e.g. different ethnic groups, cultures, or other divisions
within society), and view the context xt
j at round t as representing information about a particular
individual from that population. Each population has its own underlying function fj which maps
contexts to expected payoff2. At each time step t, the algorithm is asked to choose between specific
members of each population, represented by the contexts xt
j. The quality of an individual is thus
exactly E
h
rt
j
i
= fj(xt
j). Our fairness condition translates thus: for any pair of arms j, j0 at time
t, if fj(xt
j) â‰¥ fj0 (xt
j0 ), then an algorithm is said to be discriminatory if it preferentially chooses the
lower quality arm j0. Said another way, an algorithm is fair if it guarantees the following: with
high probability, over all rounds t, and for all pairs of arms j, j0, whenever fj(xt
j) â‰¥ fj0 (xt
j0 ), the
algorithm chooses arm j with probability at least that with which it chooses arm j03.
It is worth noting that this definition of fairness (formalized in the preliminaries) is entirely
consistent with the optimal policy, which can simply choose at each round to play uniformly at
random from the arms arg maxj

E
h
rt
j
i
which maximize the expected reward. This is because â€“
it seems â€“ the goal of fairness as enunciated above is entirely consistent with the goal of maximizing
expected reward. Indeed, the fairness constraint exactly states that the algorithm cannot favor low
reward arms!
Our main conceptual result is that this intuition is incorrect in the face of unknown reward
functions. Even though the constraint of fairness is consistent with implementing the optimal
policy, it is not necessarily consistent with learning the optimal policy. We show that fairness
always has a cost, in terms of the achievable learning rate of the algorithm. For some problems,
the cost is mild, but for others, the cost is large.
1.2 Our Results
We divide our results into two parts. First, we study the classic stochastic multi-armed bandit
problem [Lai and Robbins, 1985, Katehakis and Robbins, 1995]. In this case, there are no contexts,
and each arm i has a fixed but unknown average reward Âµi. Note that this is a special case of
the contextual bandit problem in which the contexts are the same every day. In this setting, our
fairness constraint specializes to require that with probability 1 âˆ’ Î´, for any pair of arms i, j for
which Âµi â‰¥ Âµj, at no round t does the algorithm play arm j with probability higher than that with
which it plays arm i. Note that even this special case models interesting scenarios from the point
of view of fairness in learning. It models, for example, the case in which choices are made by a loan
officer after applicants have been categorized into k internally indistinguishable equivalence classes
based on their applications.
Without a fairness constraint, it is known that it is possible to guarantee non-trivial regret
to the optimal policy after only T = O(k) many rounds [Auer et al., 2002]. In Section 3, we
give an algorithm that satisfies our fairness constraint and is able to guarantee non-trivial regret
after T = O(k3) rounds. We then show in Section 4 that it is not possible to do better â€“ any
2
It is natural that different populations should have different underlying functions â€“ for example, in a college
admissions setting, the function mapping applications to college success probability might weight SAT scores less in
a wealthy population that employs SAT tutors, and more in a working-class population that does not â€“ see Dwork
et al. [2012] for more discussion of this issue and Munoz et al. [2016] for examples.
3
Note that the definition does not require equality of outcomes on a population wide basis, also known as statistical
parity. If some population j is less credit-worthy on average than another population j0
, we do not necessarily say
that an algorithm is discriminatory if it ends up giving fewer loans to individuals from population j. Our notion
of discrimination is on an individual basis â€“ it requires that even if population j is less credit worthy on average
than population j0
, if it happens that on some day, an individual appears from population j who is at least as credit
worthy as the individual from population j0
, then the algorithm cannot favor the individual from population j0
.
4
fair learning algorithm can be forced to endure constant per-round regret for T = â„¦(k3) rounds.
Thus, we tightly characterize the optimal regret attainable by fair algorithms in this setting, and
formally separate it from the regret attainable by algorithms absent a fairness constraint. Note
that this already shows a separation between the best possible learning rates for contextual bandit
learning with and without the fairness constraint â€“ the stochastic multi-armed bandit problem is a
special case of every contextual bandit problem, and for general contextual bandit problems, it is
also known how to get non-trivial regret after only T = O(k) many rounds [Agarwal et al., 2014,
Beygelzimer et al., 2011, Chu et al., 2011].
We then move on to the general contextual bandit setting and prove a broad characterization
result, relating fair contextual bandit learning to KWIK learning [Li et al., 2011]. The KWIK
model, which stands for Knows What it Knows and has a close relationship with reinforcement
learning, is a model of sequential supervised classification in which the learning algorithm must be
confident in its predictions. Informally, a KWIK learning algorithm receives a sequence of unlabeled
examples, whose true labels are defined by some unknown function in a class C. For each example,
the algorithm may either predict a label, or announce â€œI Donâ€™t Knowâ€. The KWIK requirement is
that with high probability, for each example, if the algorithm predicts a label, then its prediction
must be very close to the true label. The quality of a KWIK learning algorithm is characterized
by its â€œKWIK boundâ€, which provides an upper bound on the maximum number of times the
algorithm can be forced to announce â€œI Donâ€™t Knowâ€. For any contextual bandit problem (defined
by the set of functions C from which the payoff functions fj may be selected), we show that the
optimal learning rate of any fair algorithm is determined by the best KWIK bound for the class
C. We prove this constructively â€“ we give a reduction showing how to convert a KWIK learning
algorithm into a fair contextual bandit algorithm in Section 5, and vice versa in Section 6. Both
reductions show that the KWIK bound of the KWIK algorithm is polynomially related to the regret
of the fair algorithm.
This general connection has immediate implications, because it allows us to import known
results for KWIK learning [Li et al., 2011]. For example, it implies that some fair contextual bandit
problems are easy, in that there are fair algorithms which can obtain non-trivial regret guarantees
after polynomially many rounds. This is the case, for example, for the important linear special
case in which the contexts xt
j âˆˆ Rd are real valued vectors and the unknown functions fj are linear:
fj(xt
j) = hÎ¸j, xt
ji4. In this case, the KWIK-learnability of noisy linear regression problems [Strehl
and Littman, 2008, Li et al., 2011] implies that we can construct a fair contextual bandit algorithm
whose per-round regret is polynomial in d. Conversely, it also implies that some contextual bandit
problems which are easy without the fairness constraint become hard once we impose the fairness
constraint, in that any fair algorithm must suffer constant per-round regret for exponentially many
rounds. This is the case, for example, when the context consists of boolean vectors xt
j âˆˆ {0, 1}d,
and the unknown functions fj : {0, 1}d â†’ {0, 1} are conjunctions â€“ the â€œandâ€s of some unknown
set of features5. The impossibility of non-trivial KWIK-learning of conjunctions [Li, 2009, Li et al.,
2011] implies that no fair learner in the contextual bandit setting can achieve non-trivial regret
before exponentially many (in d) rounds.
4
This corresponds to the case in which the probability that an individual pays back his or her loan is determined
by a standard linear regression model.
5
For example, a conjunction might predict that an individual is likely to pay back his loan if all of the following
conditions are satisfied: he or she has graduated from college, has a clean driving history, and has not previously
defaulted on any loans.
5
1.3 Other Related Work
Several papers study the problem of fairness in machine learning. One line of work aims to give
algorithms for batch classification which achieve group fairness otherwise known as equality of
outcomes, statistical parity â€“ or algorithms that avoid disparate impact (see e.g. Calders and Verwer
[2010], Luong et al. [2011], Kamishima et al. [2011], Feldman et al. [2015], Fish et al. [2016] and Adler
et al. [2016] for a study of auditing existing algorithms for disparate impact). While statistical parity
is sometimes a desirable goal â€“ indeed, it is sometimes required by law â€“ as observed by Dwork et al.
[2012] and others, it suffers from two problems. First, if different populations indeed have different
statistical properties, then it can be at odds with accurate classification. Second, even in cases
when statistical parity is attainable with an optimal classifier, it does not prevent discrimination at
an individual level â€“ see Dwork et al. [2012] for a catalog of ways in which statistical parity can be
insufficient from the perspective of fairness. In contrast, we study a notion aimed at guaranteeing
fairness at the individual level.
Our definition of fairness is most closely related to that of Dwork et al. [2012], who proposed
and explored the basic properties of a technical definition of individual fairness formalizing the
idea that â€œsimilar individuals should be treated similarlyâ€. Specifically, their work presupposes the
existence of a task-specific metric on individuals, and proposes that fair algorithms should satisfy
a Lipschitz condition with respect to this metric. Our definition of fairness is similar, in that
the expected reward of each arm is a natural metric through which we define fairness. The main
conceptual distinction between our work and Dwork et al. [2012] is that their work operates under
the assumption that the metric is known to the algorithm designer, and hence in their setting, the
fairness constraint binds only insofar as it is in conflict with the desired outcome of the algorithm
designer. The most challenging aspect of this approach (as they acknowledge) is that it requires
that some third party design a â€œfairâ€ metric on individuals, which in a sense encodes much of the
relevant challenge. The question of how to design such a metric was considered by Zemel et al.
[2013], who study methods to learn representations that encode the data, while obscuring protected
attributes. Our fairness constraint, conversely, is entirely aligned with the goal of the algorithm
designer in that it is satisfied by the optimal policy; nevertheless, it affects the space of feasible
learning algorithms, because it interferes with learning an optimal policy, which depends on the
unknown reward functions.
At a technical level, our work is related to Amin et al. [2012] and Amin et al. [2013], which also
relate KWIK learning to bandit learning in a different context, unrelated to fairness (when the arm
space is very large).
2 Preliminaries
We study the contextual bandit setting, which is defined by a domain X, a set of â€œarmsâ€ [k] :=
{1, . . . , k} and a class C of functions of the form f : X â†’ [0, 1]. For each arm j there is some function
fj âˆˆ C, unknown to the learner. In rounds t = 1, . . . , T, an adversary reveals to the algorithm a
context xt
j for each arm6. An algorithm A then chooses an arm it, and observes stochastic reward
rt
it
for the arm it chose. We assume rt
j âˆ¼ Dt
j, E
h
rt
j
i
= fj(xt
j), for some distribution Dt
j over [0, 1].
Let Î  be the set of policies mapping contexts to distributions over arms Xk â†’ âˆ†k, and Ï€âˆ— the
optimal policy which selects a distribution over arms as a function of contexts to maximize the
expected reward of those arms. The pseudo-regret of an algorithm A on contexts x1, . . . , xT is
6
Often, the contextual bandit problem is defined such that there is a single context xt
every day. Our model is
equivalent â€“ we could take xt
j := xt
for each j.
6
defined as follows, where Ï€t represents Aâ€™s distribution on arms at round t:
X
t
Eit
âˆ—âˆ¼Ï€âˆ—(xt)
h
fit
âˆ—
(xt
it
âˆ—
)
i
âˆ’ Eitâˆ¼Ï€t
"
X
t
fit (xt
it )
#
= Regret(x1
, . . . , xT
).
We hereafter refer to this as the regret of A. The optimal policy Ï€âˆ— pulls arms with highest
expectation at each round, so:
Regret(x1
, . . . , xT
) =
X
t
max
j
fj(xt
j)

âˆ’ Eitâˆ¼Ï€t
"
X
t
fit (xt
it )
#
.
We say that A satisfies regret bound R(T) if maxx1,...,xT Regret(x1, . . . , xt) â‰¤ R(T).
Let the history ht âˆˆ Xk Ã— [k] Ã— [0, 1]
tâˆ’1
be a record of t âˆ’ 1 rounds experienced by A, t âˆ’ 1
3-tuples which encode for each t the realization of the contexts, arm chosen, and reward observed.
We write Ï€t
j|ht to denote the probability that A chooses arm j after observing contexts xt, given
ht. For notational simplicity, we will often drop the superscript t on the history when referring to
the distribution over arms: Ï€t
j|h
:= Ï€t
j|ht .
We now define what it means for a contextual bandit algorithm to be Î´-fair with respect to
its arms. Informally, this will mean that A will play arm i with higher probability than arm j in
round t only if i has higher mean than j in round t, for all i, j âˆˆ [k], and in all rounds t.
Definition 1 (Î´-fair). A is Î´-fair if, for all sequences of contexts x1, . . . , xt and all payoff distribu-
tions Dt
1, . . . , Dt
k, with probability at least 1 âˆ’ Î´ over the realization of the history h, for all rounds
t âˆˆ [T] and all pairs of arms j, j0 âˆˆ [k],
Ï€t
j|h > Ï€t
j0|h only if fj(xt
j) > fj0 (xt
j0 ).
Remark 1. Definition 1 prohibits favoring lower payoff arms over higher payoff arms. One relaxed
definition only requires that Ï€t
j|h = Ï€t
j0|h when fj(xt
j) = fj0 (xt
j0 ) â€“ requiring only identical individuals
(concerning expected payoff) be treated identically. This relaxation is a special case of Dwork et al.
[2012]â€™s proposed family of definitions, which require that â€œsimilar individuals be treated similarlyâ€.
We use Definition 1 as it is better motivated in its implications for fair treatment of individuals,
but all of our results â€“ including our lower bounds â€“ apply also to this relaxation.
KWIK learning Let B be an algorithm which takes as input a sequence of examples x1, . . . , xT ,
and when given some xt âˆˆ X, outputs either a prediction yÌ‚t âˆˆ [0, 1] or else outputs yÌ‚t = âŠ¥,
representing â€œI donâ€™t knowâ€. When yÌ‚t = âŠ¥, B receives feedback yt such that E

yt

= f(xt). B is
an (, Î´)-KWIK learning algorithm for C : X â†’ [0, 1], with KWIK bound m(, Î´) if for any sequence
of examples x1, x2, . . . and any target f âˆˆ C, with probability at least 1 âˆ’ Î´, both:
1. Its numerical predictions are accurate: for all t, yÌ‚t âˆˆ {âŠ¥} âˆª [f(xt) âˆ’ , f(xt) + ], and
2. B rarely outputs â€œI Donâ€™t Knowâ€:
Pâˆ
t=1 I

yÌ‚t = âŠ¥

â‰¤ m(, Î´).
2.1 Specializing to Classic Stochastic Bandits
In Sections 3 and 4, we study the classic stochastic bandit problem, an important special case of
the contextual bandit setting described above. Here we specialize our notation to this setting, in
which there are no contexts. For each arm j âˆˆ [k], there is an unknown distribution Dj over [0, 1]
7
with unknown mean Âµj. A learning algorithm A chooses an arm it in round t, and observes the
reward rt
it
âˆ¼ Dit
for the arm that it chose. Let iâˆ— âˆˆ [k] be the arm with highest expected reward:
iâˆ— âˆˆ arg maxiâˆˆ[k] Âµi. The pseudo-regret of an algorithm A on D1, . . . , Dk is now just:
T Â· Âµiâˆ— âˆ’ Eitâˆ¼Ï€t
ï£®
ï£°
X
0â‰¤tâ‰¤T
Âµit
ï£¹
ï£» = Regret(T, D1, . . . , Dk)
Let ht âˆˆ ([k] Ã— [0, 1])tâˆ’1
denote a record of the t âˆ’ 1 rounds experienced by the algorithm so far,
represented by t âˆ’ 1 2-tuples encoding the previous arms chosen and rewards observed. We write
Ï€t
j|ht to denote the probability that A chooses arm j given history ht. Again, we will often drop
the superscript t on the history when referring to the distribution over arms: Ï€t
j|h
:= Ï€t
j|ht .
Î´-fairness in the classic bandit setting specializes as follows:
Definition 2 (Î´-fairness in the classic bandits setting). A is Î´-fair if, for all distributions D1, . . . , Dk,
with probability at least 1 âˆ’ Î´ over the history h, for all t âˆˆ [T] and all j, j0 âˆˆ [k]:
Ï€t
j|h > Ï€t
j0|h only if Âµj > Âµj0 .
3 Fair Classic Stochastic Bandits: An Algorithm
In this section, we describe a simple and intuitive modification of the standard UCB algorithm [Auer
et al., 2002], called FairBandits, prove that it is fair, and analyze its regret bound. The algorithm
and its analysis highlight a key idea that is important to the design of fair algorithms in this setting:
that of chaining confidence intervals. Intuitively, as a Î´-fair algorithm explores different arms it
must play two arms j1 and j2 with equal probability until it has sufficient data to deduce, with
confidence 1 âˆ’ Î´, either that Âµj1 > Âµj2 or vice versa. FairBandits does this by maintaining
empirical estimates of the means of both arms, together with confidence intervals around those
means. To be safe, the algorithm must play the arms with equal probability while their confidence
intervals overlap. The same reasoning applies simultaneously to every pair of arms. Thus, if the
confidence intervals of each pair of arms ji and ji+1 overlap for each i âˆˆ [k], the algorithm is
forced to play all arms j with equal probability. This is the case even if the confidence intervals
around arm jk and arm j1 are far from overlapping â€“ i.e. when the algorithm can be confident that
Âµj1 > Âµjk
.
This approach initially seems naive: in an attempt to achieve fairness, it seems overly conser-
vative when ruling out arms, and can be forced to play arms uniformly at random for long periods
of time. This is reflected in its regret bound, which is only non-trivial after T  k3, whereas the
UCB algorithm [Auer et al., 2002] achieves non-trivial regret after T = O(k) rounds. However, our
lower bound in Section 4 shows that any fair algorithm must suffer constant per-round regret for
T  k3 rounds on some instances.
We now give an overview of the behavior of FairBandits. At every round t, FairBandits
identifies the arm it
âˆ— = arg maxi ut
i that has the largest upper confidence interval amongst the active
arms. At each round t, we say i is linked to j if [`t
i, ut
i] âˆ© [`t
j, ut
j] 6= âˆ…, and i is chained to j if i and
j are in the same component of the transitive closure of the linked relation. FairBandits plays
uniformly at random among all active arms chained to arm it
âˆ—.
Initially, the active set contains all arms. The active set of arms at each subsequent round is
defined to be the set of arms that are chained to the arm with highest upper confidence bound at
the previous round. The algorithm can be confident that arms that have become unchained to the
8
arm with the highest upper confidence bound at any round have means that are lower than the
means of any chained arms, and hence such arms can be safely removed from the active set, never
to be played again. This has the useful property that the active set of arms can only shrink: at
any round t, St âŠ† Stâˆ’1; see Figure 1 for an example of active set evolution over time.
1: procedure FairBandits(Î´)
2: S0 â† {1, . . . , k} . Initialize the active set
3: for i = 1, . . . k do
4: ÂµÌ‚0
i â† 1
2, u0
i â† 1, `0
i â† 0, n0
i â† 0 . Initialize each arm
5: for t = 1 to T do
6: it
âˆ— â† arg maxiâˆˆStâˆ’1 ut
i . Find arm with highest ucb
7: St â† {j | j chains to it
âˆ—, j âˆˆ Stâˆ’1} . Update active set
8: jâˆ— â† (x âˆˆR St) . Select active arm at random
9: nt+1
jâˆ— â† nt
jâˆ— + 1
10: ÂµÌ‚t+1
jâˆ— â† 1
nt+1
jâˆ—
(ÂµÌ‚t
jâˆ— Â· nt
jâˆ— + rt
jâˆ— ) . Pull arm jâˆ—, update its mean estimate
11: B â†
r
ln((Ï€Â·(t+1))2/3Î´)
2nt+1
jâˆ—
12:
h
`t+1
jâˆ— , ut+1
jâˆ—
i
â†
h
ÂµÌ‚t+1
jâˆ— âˆ’ B, ÂµÌ‚t+1
jâˆ— + B
i
. Update interval for pulled arm
13: for j âˆˆ St, j 6= jâˆ— do
14: ÂµÌ‚t+1
j â† ÂµÌ‚t
j, nt+1
j â† nt
j, ut+1
j â† ut
j, `t+1
j â† `t
j
We first observe that with probability 1 âˆ’ Î´, all of the confidence intervals maintained by
FairBandits (Î´) contain the true means of their respective arms over all rounds. We prove this
claim, along with all other claims in this section without proofs, in Appendix A.
Lemma 1. With probability at least 1 âˆ’ Î´, for every arm i and round t `t
i â‰¤ Âµi â‰¤ ut
i.
The fairness of FairBandits follows almost immediately from this guarantee.
Theorem 1. FairBandits (Î´) is Î´-fair.
Proof. By Lemma 1, with probability at least 1âˆ’Î´ all confidence intervals contain their true means
across all rounds. Thus, with probability 1âˆ’Î´, at every round t, for every i âˆˆ St, j /
âˆˆ St, it must be
that Âµj < Âµi â€“ the arms not in the active set have strictly smaller means than those in the active
set; if not, ut
j â‰¥ Âµj â‰¥ Âµi â‰¥ `t
i implies j would be chained to it
âˆ— if i is. Finally, all arms in St are
played uniformly at random â€“ but since all such arms are played with the same probability, this
does not cause the fairness constraint to bind for any pair i, i0 âˆˆ St, for any realization of Âµi, Âµ0
i
which lie within their confidence intervals.
Next, we upper bound the regret of FairBandits.
Theorem 2. If Î´ < 1/
âˆš
T, then FairBandits has regret
R(T) = O
r
k3T ln
Tk
Î´
!
.
9
Figure 1: Confidence intervals over
time for the lower bound instance
outlined in Section 4 for k =
10. Lines correspond to upper and
lower confidence bounds for each
arm and cut off at the round in
which the arm leaves the active set.
Remark 2. Before proving Theorem 2, we highlight two points. First, this bound becomes non-
trivial (i.e. the average per-round regret is  1) for T = â„¦(k3). As we show in the next section, it is
not possible to improve on this. Second, the bound may appear to have suboptimal dependence on
T when compared to unconstrained regret bounds (where the dependence on T is often described
as logarithmic). However, it is known that â„¦
âˆš
kT

regret is necessary even in the unrestricted
setting (without fairness) if one does not make data-specific assumptions on an instance [Bubeck
and Cesa-Bianchi, 2012] (e.g. that there is a lower bound on the gap between the best and second
best arm). It would be possible to state a logarithmic dependence on T in our setting as well
while making assumptions on the gaps between arms, but since our fairness constraint manifests
itself as a cost that depends on k, we choose for clarity to avoid such assumptions. Without such
assumptions, our dependence on T is also optimal.
We now prove Theorem 2. Lemma 2 upper bounds the probability any arm i active in round
t has been pulled substantially fewer times than its expectation, i.e. nt
i  t
k . Lemma 3 upper
bounds the width of any confidence interval used by FairBandits in round t by Î·(t), conditioned
on i being pulled the number of times guaranteed by Lemma 2. Finally, we stitch this together to
prove Theorem 2 by upper bounding the total regret incurred for T rounds by noticing that the
regret of any arm active in round t is at most kÎ·(t).
We begin by lower bounding the probability that any arm active in round t has been pulled
substantially fewer times than its expectation.
Lemma 2. With probability at least 1 âˆ’ Î´
2t2 ,
nt
i â‰¥
t
k
âˆ’
s
t
2
ln

2k Â· t2
Î´

for all i âˆˆ St (for all active arms in round t).
We now use this lower bound on the number of pulls of active arm i in round t to upper-bound
Î·(t), an upper bound on the confidence interval width FairBandits uses for any active arm i in
round t.
10
Lemma 3. Consider any round t and any arm i âˆˆ St. Condition on nt
i â‰¥ t
k âˆ’
r
t ln(2kt2
Î´
)
2 . Then,
ut
i âˆ’ `t
i â‰¤ 2
v
u
u
u
u
t
ln

(Ï€ Â· t)2
/3Î´

2 Â· t
k âˆ’
r
t ln( 2kt2
Î´
)
2
= Î·(t).
Finally, we prove the bound on the total regret of the algorithm, using the bound on the width
of any active armâ€™s confidence interval in round t provided by Lemma 3.
Proof of Theorem 2. We condition on Âµi âˆˆ [`t
i, ut
i] for all i, t. This occurs with probability at least
1 âˆ’ Î´, by Lemma 1. We claim that this implies that arm iâˆ— with highest expected reward is always
in the active set. This follows from the fact that Âµiâˆ— âˆˆ [`t
iâˆ—
, ut
iâˆ—
] and Âµj âˆˆ [`t
j, ut
j] for all j, t; thus, if
Âµiâˆ— > Âµj, it must be that ut
iâˆ—
â‰¥ `t
j. Thus, this holds for it
âˆ—, the arm with highest upper confidence
bound in round t, so iâˆ— must be chained to it
âˆ— in round t for all t.
We further condition on the event that for all j, t,
nt
j â‰¥
t
k
âˆ’
s
t
2
ln

2kt2
Î´

,
which holds with probability at least 1 âˆ’ Ï€Î´
2 by Lemma 2 and a union bound over all times t. This
implies that, for all rounds t, for every active arm j âˆˆ St, Lemma 3 applies, and therefore
ut
j âˆ’ `t
j â‰¤ Î·(t).
Finally, we upper-bound the per-round regret of pulling any active arm i âˆˆ St at round t. Since iâˆ—
is active, any i âˆˆ St is chained to arm iâˆ—. Since all active arms have confidence interval width at
most Î·(t) and i must be chained using at most k armsâ€™ confidence intervals, we have that
`t
i â‰¥ ut
iâˆ—
âˆ’ k Â· Î·(t).
Since Âµi â‰¥ `t
i and ut
iâˆ—
â‰¥ Âµiâˆ— , it follows that |Âµi âˆ’ Âµiâˆ— | â‰¤ k Â· Î·(t) for any i âˆˆ St. Finally, summing up
over all rounds t âˆˆ T, we know that
R(T) â‰¤
T
X
t:0
min(1, k Â· Î·(t)) +

1 +
Ï€
2

Î´T
â‰¤ k
ï£«
ï£¬
ï£¬
ï£­
T
X
t: t
k
>2
q
t ln 2tk
Î´
s
ln t
Î´
t
2k
+
T
X
t: t
k
â‰¤2
q
t ln 2tk
Î´
1
ï£¶
ï£·
ï£·
ï£¸ +

1 +
Ï€
2

Î´T = OÌƒ(k
3
2
r
T ln
kT
Î´
+ k3
)
where this bound is derived in Appendix A.1.
4 Fair Classic Stochastic Bandits: A Lower Bound
We now show that the regret bound for FairBandits has an optimal dependence on k: no fair
algorithm has diminishing regret before T = â„¦(k3) rounds. All missing proofs are in Appendix B.
The main result of this section is the following.
11
Theorem 3. There is a distribution P over k-arm instances of the stochastic multi-armed bandit
problem such that any fair algorithm run on P experiences constant per-round regret for at least
T = â„¦

k3
ln
1
Î´

rounds.
Despite the fact that regret is defined in a prior-free way, the proof of Theorem 3 proceeds via
Bayesian reasoning. We construct a family of lower bound instances such that arms have payoffs
drawn from Bernoulli distributions, denoted B(Âµ) for mean Âµ. So, to specify a problem instance, it
suffices to specify a mean for each of k arms: Âµ1, . . . , Âµk. The proof formalizes the following outline.
1. We define an instance distribution P = P1 Ã—. . .Ã—Pk over means Âµi (Definition 3). P will have
two important properties. First, we will draw means from P such that for any i âˆˆ [k âˆ’ 1],
Âµi = Âµi+1 with probability at least 1/4. Second, for any realization of means drawn from P,
if an algorithm plays uniformly at random over [k], it will suffer constant per-round regret.
2. We treat Pi as a prior distribution over mean Âµi, and analyze the posterior distribution
Pi(r1
i , , . . . , rt
i) over means that results after applying Bayesâ€™ rule to the payoff observations
r1
i , . . . , rt
i made by the algorithm. Bayesâ€™ rule implies (Lemma 4) the joint distribution over
rewards and means drawn from P is identical to the distribution which first draws means
according to P, then draws rewards conditioned on those means, and finally resamples the
means from the posterior distribution on means. Thus, we can reason about fairness (a
frequentist quantity) by analyzing the Bayesian posterior distribution on means conditioned
on the observed rewards.
3. A Î´-fair algorithm, for any set of means realized from the instance (prior) distribution, must
not play arm i + 1 with lower probability than arm i if Âµi = Âµi+1, except with probability
Î´. By the above change of perspective, therefore, any Î´-fair algorithm must play arms i and
i+1 with equal probability until the posterior distribution on means given observed rewards,
satisfies P [Âµi = Âµi+1|h] < Î´ (Lemmas 5 and 6).
4. We finally lower bound the number of reward observations necessary before the posterior
distribution on means given payoffs is such that P [Âµi = Âµi+1|h] < Î´ for any pair of adjacent
arms i, i + 1. We show that this is â„¦(k2) (Lemma 7). Since fair algorithms must play
from among the k arms uniformly at random until this point, with high probability, no arm
accumulates sufficiently many reward observations until T = â„¦(k3) rounds of play.
We begin by describing our distribution over instances. Each arm iâ€™s payoff distribution will be
Bernoulli with mean Âµi âˆ¼ Pi independently of each other arm.
Definition 3 (Prior Distribution over Âµi). For each arm i, Âµi is distributed according to the
distribution with the following probability mass function:
Pi(x) =
(
1
2 if x = 1
3 + i
3k
1
2 if x = 1
3 + i+1
3k .
Let P =
Q
i Pi denote the joint distribution on armsâ€™ expected payoffs.
We treat P as a prior distribution over instances, and analyze the posterior distribution on
instances given the realized rewards. Lemma 4 justifies this reasoning.
12
Lemma 4. Consider the following two experiments: In the first, let Âµi âˆ¼ Pi and r1
i , . . . , rt
i âˆ¼
B(Âµi), and W denote the joint distribution on (Âµi, r1
i , . . . , rt
i). In the second, let Âµi âˆ¼ Pi, and
r1
i , . . . , rt
i âˆ¼ B(Âµi), and then re-draw the mean Âµ0
i âˆ¼ Pi(r1
i , . . . , rt
i) from its posterior distribution
given the rewards. Let (Âµ0
i, r1
i , . . . , rt
i) âˆ¼ W0. Then, W and W0 are identical distributions.
Next, we lower-bound the number of reward observations necessary such that for some i âˆˆ [k]:
P

Âµi = Âµi+1|ht

< Î´ with respect to the posterior. It will be useful to refer to an algorithmâ€™s
histories as distinguishing the mean of an arm given that history with high probability.
Definition 4 (Î´-distinguishing). We will say ht Î´-distinguishes arm i for A if, for some Î± âˆˆ [0, 1],
PÂµ0
iâˆ¼Pi(ht)

Âµ0
i = Î±

â‰¥ 1 âˆ’ Î´.
The next lemma shows that if no arm is
âˆš
Î´-distinguished by a history, all pairs of arms i, i + 1
have posterior probability strictly greater than Î´ of having equal means.
Lemma 5. Suppose A has history ht, and that ht does not
âˆš
Î´-distinguish any arm i. Then, for
all arms i, i + 1,
P

Âµi = Âµi+1|ht

> Î´.
Now, we prove that for any fair algorithm, with probability â‰¥ 1
2 over the draw of histories ht, ht
must
âˆš
2Î´-distinguish some arm, or the algorithm must play uniformly across all k arms conditioned
on ht.
Lemma 6. Suppose an algorithm A is Î´-fair. Then:
Phtâˆ¼A

ht
does not
âˆš
2Î´-distinguish any i âˆ§ âˆƒt0
â‰¤ t, i âˆˆ [k] : Ï€t0
i0|ht0 6=
1
k

â‰¤
1
2
.
We now lower-bound the number of observations from arm i which are required to Î´-distinguish
it.
Lemma 7. Fix any Î´ < 1
8. Let Âµi âˆ¼ Pi as in Definition 3. Then, arm i is
âˆš
2Î´-distinguishable by
ht only if Ti = â„¦(k2 ln 1
Î´ ), where Ti = |{t0 : ht0
2 = i, t0 â‰¤ t}| is the number of times arm i is played.
Proof. Write p, p + 1
3k to represent the two possible realizations that Âµi might take, when drawn
from the distribution over instances given in Definition 3. Let A represent the event that Âµi = p
and B the event that Âµi = p + 1
3k . Let Î´0 =
âˆš
2Î´ throughout.
Fix a history ht, and let m = Ti represent the number of observations of arm iâ€™s reward. We
will abuse notation and use ht
i to refer to the payoff sequence of arm i observed in history ht. ht
i is
therefore a binary sequence of length m; let ||ht
i||0 = s denote the number of 1s in the sequence. We
will calculate conditions under which ht
i, m, s will imply that either 1âˆ’Î´0
Î´0 â‰¤
P[B|ht
i]
P[A|ht
i]
or
P[B|ht
i]
P[A|ht
i]
â‰¤ Î´0
1âˆ’Î´0
holds, implying that one of A or B has posterior probability at least 1 âˆ’ Î´0, conditioned on the
observed rewards. If neither of these is the case, i is not Î´0-distinguished by ht.
We begin by rearranging our definition of this ratio X =
P[B|ht
i]
P[A|ht
i]
=
P[ht
i|B]
P[ht
i|A]
,which follows from
Bayesâ€™ rule and the fact that P [A] = P [B]. We wish to upper and lower bound X in terms of ht
iâ€™s
value. By definition of the Bernoulli distribution, we have that
X =
P

ht
i|B

P [ht
i|A]
=
p + 1
3k
s
1 âˆ’ p âˆ’ 1
3k
mâˆ’s
(p)s
(1 âˆ’ p)mâˆ’s =

1 +
1
3kp
s 
1 âˆ’
1
3k(1 âˆ’ p)
mâˆ’s
.
13
We now calculate under what conditions either (a) X â‰¤ Î´0
1âˆ’Î´0 , or (b) X â‰¥ 1âˆ’Î´0
Î´0 . One of these must
hold if i is Î´0-distinguished. Before we do so, we mention that a Chernoff bound implies that with
probability 1 âˆ’ Î´0, for events A and B, Equations 1 and 2, respectively:
|s âˆ’ mp| â‰¤
r
2m ln
2
Î´0
(1) |s âˆ’ mp âˆ’
m
3k
| â‰¤
r
2m ln
2
Î´0
(2)
since the mean of m Bernoulli trials with mean p ( or p + 1
3k ) is mp (or mp + m
3k ).
We begin by analyzing case (a), where Î´0 =
âˆš
2Î´ < 1/2 implies
2Î´0
>
Î´0
1 âˆ’ Î´0
â‰¥ X =

1 +
1
3kp
s 
1 âˆ’
1
3k(1 âˆ’ p)
mâˆ’s
.
Taking logarithms on both sides, we have that
ln(2Î´0
) > s ln

1 +
1
3kp

+ (m âˆ’ s) ln

1 âˆ’
1
3k(1 âˆ’ p)

â‰¥ s
1
3kp + 1
âˆ’ (m âˆ’ s)
1
3k(1 âˆ’ p) âˆ’ 1
where the inequality follows from ln(1 + x) â‰¥ x
x+1 for x âˆˆ [âˆ’1, âˆ]. Then, this implies that
(3kp + 1)(3k(1 âˆ’ p) âˆ’ 1) ln(2Î´0
) > s(3k(1 âˆ’ p) âˆ’ 1) âˆ’ (m âˆ’ s)(3kp + 1) = 3ks âˆ’ 3kpm âˆ’ m.
Multiplying both sides by âˆ’1, this implies that
(3kp + 1)(3k(1 âˆ’ p) âˆ’ 1) ln
1
2Î´0
< m + 3kpm âˆ’ 3ks.
Equation 1 implies |3ks âˆ’ 3kmp âˆ’ m| â‰¤ m + 3k
q
2m ln 2
Î´0 , which with the previous line implies
(3kp + 1)(3k(1 âˆ’ p) âˆ’ 1) ln
1
2Î´0
< m + 3k
r
2m ln
2
Î´0
.
Since p, 1 âˆ’ p âˆˆ [1/3, 2/3] and Î´0 =
âˆš
2Î´, solving for m implies that m = â„¦(k2 ln 1
Î´0 ).
In case (b), we have
1
2Î´0
<
1 âˆ’ Î´0
Î´0
â‰¤ X =

1 +
1
3kp
s 
1 âˆ’
1
3k(1 âˆ’ p)
mâˆ’s
â‰¤ e
s
3kp e
âˆ’(mâˆ’s)
3k(1âˆ’p)
where we used the fact that 1 + x â‰¤ ex for all x. Taking logarithms, this will imply that
s
3kp
âˆ’
m âˆ’ s
3k(1 âˆ’ p)
> ln
1
2Î´0
â‡’ s âˆ’ mp = s(1 âˆ’ p) âˆ’ (m âˆ’ s)p > 3kp(1 âˆ’ p) ln
1
2Î´0
â‰¥
6k
9
ln
1
2Î´0
(3)
whose last inequality comes the range of p. Combining this inequality with Equation 2, this implies
r
2m ln
1
2Î´0
+
m
k
>
6k
9
ln
1
2Î´0
and solving for m and substituting for Î´0 gives that m = â„¦(k2 ln 1
Î´ ).
Thus, if either X â‰¥ 1âˆ’Î´0
Î´0 or X â‰¤ Î´0
1âˆ’Î´0 , it must be that m = â„¦(k2 ln 1
Î´ ).
We now have the tools in hand to prove Theorem 3.
14
Proof of Theorem 3. Assume A is some Î´-fair algorithm where Î´ < 1/8. Fix T; we claim that with
probability at least 1
2, for any t = o(k3 ln 1
Î´ ), t â‰¤ T, Ï€t
j|ht = 1
k for all j. Since the payoff for uniformly
random play is â‰¤ 1
2 + 1
k , while the best arm has payoff â‰¥ 2
3, in any round t where Ï€t
i|ht = Ï€t
i0|ht for
all i, i0 âˆˆ [k], the algorithm suffers â„¦(1) regret in that round.
Lemma 6 implies that, with probability at least 1
2 over the distribution over histories ht, either
(a) Ï€t0
i|ht0 = Ï€t0
i0|ht0 for all i, i0 âˆˆ [k], t0 â‰¤ t or (b) ht must
âˆš
2Î´-distinguish some arm i. Case (a) implies
our claim. In case (b), Lemma 7 states than an arm i is
âˆš
2Î´-distinguishable only if Ti = â„¦(k2 ln 1
Î´ ).
We now argue that unless t = â„¦(k3 ln 1
Î´ ), Ti = o(k2 ln 1
Î´ ), which will imply our claim for case (b).
Fix some i, t. We lower-bound t for which, with probability at least 1 âˆ’ Î´0
k over histories ht, it
will be the case that nt
i â‰¥ c Â· k2 ln 1
Î´ when Ï€t0
i|ht0 = Ï€t0
i0|ht0 for all i, i0 âˆˆ [k], t0 â‰¤ t. Let X1, . . . , Xt be
indicator variables of arm i being played in round t0 â‰¤ t. Note that for all t0 â‰¤ t, E[Xt0 ] = 1
k , since
in all rounds prior to t, we have all arms are played with equal probability. For any  âˆˆ [0, 1], as
nt0
i are nondecreasing in t0, an additive Chernoff bound implies
P

âˆƒt0
â‰¤ t : nt0
i â‰¥
t
k
+ t

â‰¤ P
ï£®
ï£°
X
t0â‰¤t
Xt0 >
t
k
+ t
ï£¹
ï£» â‰¤ eâˆ’2t2
which, for t =
q
t ln 2k
Î´0
2 , becomes P
hP
t0â‰¤t Xt0 > t
k + t
i
â‰¤ Î´0
k . So, using a union bound over all k
arms, with probability 1 âˆ’ Î´0, for some fixed t and all i, nt
i â‰¤ t
k +
q
t ln 2k
Î´0
2 . We condition on the
event that nt
i satisfies this inequality for a fixed t and all i. If nt
i â‰¥ c Â· k2 ln 1
Î´ , this implies
t
k
+
s
t ln 2k
Î´0
2
â‰¥ c Â· k2
ln
1
Î´
â‡’ t â‰¥ âˆ’k
s
t ln 2k
Î´0
2
+ c Â· k3
ln
1
Î´
.
If k
q
t ln 2k
Î´0
2 â‰¤ c
2 Â· k3 ln 1
Î´ , then t â‰¥ c
2 Â· k3 ln 1
Î´ ; if not, then t â‰¥
c2
2
k4 ln2 1
Î´
ln 2k
Î´0
. Thus, nt
i < c Â· k2 ln 1
Î´ with
probability 1 âˆ’ Î´0 for all i unless t â‰¥ min

c
2 Â· k3 ln 1
Î´ ,
c2
2
k4 ln2 1
Î´
ln 2k
Î´0

= â„¦(k3 ln 1
Î´ ) for Î´0 âˆˆ [1
2, 1].
5 KWIK Learnability Implies Fair Bandit Learnability
In this section, we show if a class of functions is KWIK learnable, then there is a fair algorithm
for learning the same class of functions in the contextual bandit setting, with a regret bound
polynomially related to the function classâ€™ KWIK bound. Intuitively, KWIK-learnability of a class
of functions guarantees we can learn the functionâ€™s behavior to a high degree of accuracy with a high
degree of confidence. As fairness constrains an algorithm most before the algorithm has determined
the payoff functionsâ€™ behavior accurately, this guarantee enables us to learn fairly without incurring
much additional regret. Formally, we prove the following polynomial relationship.
Theorem 4. For an instance of the contextual multi-armed bandit problem where fj âˆˆ C for
all j âˆˆ [k], if C is (, Î´)-KWIK learnable with bound m(, Î´), KWIKToFair (Î´, T) is Î´-fair and
achieves regret bound:
R(T) = O

max

k2
Â· m

âˆ—
,
min (Î´, 1/T)
T2k

, k3
ln
k
Î´

for Î´ â‰¤ 1
âˆš
T
where âˆ— = arg min(max( Â· T, k Â· m(, min(Î´,1/T)
kT2 ))).
15
First, we construct an algorithm KWIKToFair(Î´, T) that uses the KWIK learning algorithm
as a subroutine, and prove that it is Î´-fair. A call to KWIKToFair(Î´, T) will initialize a KWIK
learner for each arm, and in each of the T rounds will implicitly construct a confidence interval
around the prediction of each learner. If a learner makes a numeric valued prediction, we will
interpret this as a confidence interval centered at the prediction with width âˆ—. If a learner outputs
âŠ¥, we interpret this as a trivial confidence interval (covering all of [0, 1]). We use the same chaining
technique that we use in the classic stochastic setting. In every round t, KWIKToFair (Î´, T)
identifies the arm it
âˆ— = arg maxi ut
i that has the largest upper confidence bound. At each round
t, we will say i is linked to j if [`t
i, ut
i] âˆ© [`t
j, ut
j] 6= âˆ…, and i is chained to j if they are in the same
component of the transitive closure of the linked relation. Then, it plays uniformly at random
amongst all arms chained to arm it
âˆ—. Whenever all learners output predictions, they need no
feedback. When a learner for j outputs âŠ¥, if j is selected then we have feedback rt
j to give it; on
the other hand, if j isnâ€™t selected, we â€œroll backâ€ the learning algorithm for j to before this round
by not updating the algorithmâ€™s state.
1: procedure KWIKToFair(Î´, T)
2: Î´âˆ— â†
min(Î´, 1
T
)
kT2 , âˆ— â† arg min(max( Â· T, k Â· m(, Î´âˆ—)))
3: Initialize KWIK(âˆ—, Î´âˆ—)-learner Li, hi â† [ ] âˆ€i âˆˆ [k]
4: for 1 â‰¤ t â‰¤ T do
5: S â† âˆ… . Initialize set of predictions S
6: for i = 1, . . . , k do
7: st
i â† Li(xt
i, hi)
8: S â† S âˆª st
i . Store prediction st
i
9: if âŠ¥âˆˆ S then
10: Pull jâˆ— â† (x âˆˆR [k]), receive reward rt
jâˆ— . Pick arm at random from all arms
11: else
12: it
âˆ— â† arg maxi st
i
13: St â† {j | (st
j âˆ’ âˆ—, st
j + âˆ—) chains to (st
it
âˆ—
âˆ’ âˆ—, st
it
âˆ—
+ âˆ—)}
14: Pull jâˆ— â† (x âˆˆR St), receive reward rt
jâˆ— . Pick arm at random from active set st
iâˆ—
15: hjâˆ— â† hjâˆ— :: (xt
jâˆ— , rt
jâˆ— ) . Update the history for Ljâˆ—
We begin by bounding the probability of certain failures of KWIKToFair in Lemma 8, proven
in Appendix C. This in turn lets us prove the fairness of KWIKToFair in Theorem 5.
Lemma 8. With probability at least 1 âˆ’ min(Î´, 1
T ), for all rounds t and all arms i, (a) if st
i âˆˆ R
then |st
i âˆ’ fi(xt
i)| â‰¤ âˆ— and (b)
P
t I

st
i = âŠ¥ and i is pulled

â‰¤ m(âˆ—, Î´âˆ—).
Theorem 5. KWIKToFair(Î´, T) is Î´-fair.
Proof of Theorem 5. We condition on both (a) and (b) holding for all arms i and rounds t from
Lemma 8, which occur with probability 1 âˆ’ Î´ for all arms and all times t. Therefore, we proceed
by conditioning on the event that for all arms i and all rounds t, if Li = st
i for st
i 6= âŠ¥ then
|st
i âˆ’ fi(xt
i)| â‰¤ âˆ—. Having done so, there are two possibilities for each round t.
In case 1, for each i we have that Li(xt
i) = st
i 6= âŠ¥. By the condition above, for any arms i and
j, fi(xt
i) â‰¥ fj(xt
j) implies that st
i + âˆ— â‰¥ st
j âˆ’ âˆ—. Since in this case no learner outputs âŠ¥, arm j
chains to the top arm only if arm i does. Therefore Ï€t
i|h â‰¥ Ï€t
j|h. In case 2, there exists some i such
that Li(xt
i) = âŠ¥. Then we choose uniformly at random across all arms, so Ï€t
i|h = Ï€t
j|h for all i and
j.
Thus, with probability at least 1âˆ’Î´, for each round t, fi(xt
i) â‰¥ fj(xt
j) implies that Ï€t
i|h â‰¥ Ï€t
j|h.
16
We now use the KWIK bounds of the KWIK learners to upper-bound the regret of KWIKTo-
Fair(Î´, T).
Lemma 9. KWIKToFair(Î´, T) achieves regret O(max(k2 Â· m(âˆ—, Î´âˆ—), k3 ln Tk
Î´ )).
Proof. We first condition on the event that both (a) and (b) from Lemma 8 hold for all t, i, which
holds with probability 1 âˆ’ min(Î´, 1
T ), and bound the regret when they both hold. Choose an
arbitrary round t in the execution of KWIKToFair(Î´, T). As above, there are two cases. In the
first case, Li(xt
i) = st
i 6= âŠ¥ for all i and we choose uniformly at random from the arms chained by
âˆ—-intervals to the arm with the highest prediction. Since we have conditioned on the event that all
KWIK learners are correct, iâˆ— âˆˆ St. Furthermore, for any i, j âˆˆ St, we have that |st
i âˆ’ st
j| â‰¤ 2kâˆ—,
and in particular that |st
i âˆ’ st
iâˆ— | â‰¤ 2kâˆ—. Thus, the regret is at most 2kâˆ— in such a round. In the
second case some arm outputs âŠ¥, so we choose randomly from all k arms, and the worst-case regret
is 1. Thus, the total regret will be at most 2kâˆ—T + n + Î´T where n is the number of rounds in
which some Li outputs âŠ¥.
We now upper bound ni, the number of rounds in which arm i outputs âŠ¥. Fix some arm i which
outputs âŠ¥ in ni rounds. Arm i is played and therefore receives feedback every time it outputs âŠ¥
with probability at least 1/k. Thus, using a Chernoff bound, with probability 1 âˆ’ Î´0, arm i receives
feedback for ni outputs of âŠ¥ in at least ni
k âˆ’
q
2ni ln 2
Î´0 rounds. Li has the guarantee that there
can be at most m(âˆ—, Î´âˆ—) many such rounds (in which it outputs âŠ¥ and receives feedback). Thus,
m(âˆ—
, Î´âˆ—
) â‰¥
ni
k
âˆ’
r
2ni ln
2
Î´0
.
If ni â‰¥ ck Â· m(âˆ—, Î´âˆ—), this implies
m(âˆ—
, Î´âˆ—
) â‰¥ c Â· m(âˆ—
, Î´âˆ—
) âˆ’
r
2ck Â· m(âˆ—, Î´âˆ—) ln
2
Î´0
.
We now analyze cases in which (1) k ln 2
Î´0 â‰¤ m(âˆ—, Î´âˆ—) and (2) k ln 2
Î´0 > m(âˆ—, Î´âˆ—).
Case (1) this implies
m(âˆ—
, Î´âˆ—
) â‰¥ c Â· m(âˆ—
, Î´âˆ—
) âˆ’
âˆš
2c Â· m(âˆ—
, Î´âˆ—
).
For c > 4, this leads to contradiction. Thus, in this case, if we set Î´0 = Î´
k , we know that with
probability 1 âˆ’ Î´, ni â‰¤ 4k Â· m(âˆ—, Î´âˆ—) which summing up over all i implies
P
i ni â‰¤ 4k2 Â· m(âˆ—, Î´âˆ—),
as desired.
In case (2), we have that
ln
2
Î´0
â‰¥
ni
k
âˆ’
r
2ni ln
2
Î´0
which solving for ni implies that ni = O(k2 ln 1
Î´0 ), so
P
i ni = O(k3 ln k
Î´ ) by setting Î´0 = Î´
k and taking
a union bound. Thus, there are at most n = O(max(k2 Â· m(, Î´âˆ—), k3 ln k
Î´ )) rounds in expectation
during the execution of KWIKToFair(Î´, T) in which some arm outputs âŠ¥.
Combining both cases, the total regret incurred by KWIKToFair(Î´, T) across all T rounds is
R(T) = 4k2
Â· m(âˆ—
, Î´âˆ—
) + k3
ln

k
Î´

+ T Â· 2kâˆ—
+ T Â· min(Î´,
1
T
) = O(max(k2
Â· m(âˆ—
, Î´âˆ—
), k3
ln
k
Î´
)).
17
Our presentation of KWIKToFair(Î´, T) has a known time horizon T. Its guarantees extend
to the case in which T is unknown via the standard â€œdoubling trickâ€ to prove Theorem 4 in
Appendix C.
An important instance of the contextual bandit problem is the linear case, where C consists
of the set of all linear functions of bounded norm in d dimensions. This captures the natural
setting in which the rewards of each arm are governed by an underlying linear regression model
on a d-dimensional real valued feature space. The linear case is well studied, and there are known
KWIK algorithms [Strehl and Littman, 2008] for the set of linear functions C, which allows us via
our reduction to give a fair contextual bandit algorithm for this setting with a polynomial regret
bound.
Lemma 10 ([Strehl and Littman, 2008]). Let C = {fÎ¸|fÎ¸(x) = hÎ¸, xi, Î¸ âˆˆ Rd, ||Î¸|| â‰¤ 1} and
X = {x âˆˆ Rd : ||x|| â‰¤ 1}. C is KWIK learnable with KWIK bound m(, Î´) = OÌƒ(d3/4).
Then, an application of Theorem 4 implies that KWIKToFair has a polynomial regret guar-
antee for the class of linear functions. This proof can be found in Appendix C.
Corollary 1. Let C and X be as in Lemma 10, and fj âˆˆ C for each j âˆˆ [k]. Then, KWIKTo-
Fair(T, Î´) using the learner from [Strehl and Littman, 2008] has regret:
R(T) = OÌƒ

max

T4/5
k6/5
d3/5
, k3
ln
k
Î´

.
6 Fair Bandit Learnability Implies KWIK Learnability
In this section, we show how to use a fair, no-regret contextual bandit algorithm to construct
a KWIK learning algorithm whose KWIK bound has logarithmic dependence on the number of
rounds T. Intuitively, any fair algorithm which achieves low regret must both be able to find and
exploit an optimal arm (since the algorithm is no-regret) and can only exploit that arm once it
has a tight understanding of the qualities of all arms (since the algorithm is fair). Thus, any fair
no-regret algorithm will ultimately have tight (1 âˆ’ Î´)-confidence about each armâ€™s reward function.
Theorem 6. Suppose A is a Î´-fair algorithm for the contextual bandit problem over the class of
functions C, with regret bound R(T, Î´). Suppose also there exists f âˆˆ C, x(`) âˆˆ X such that for
every ` âˆˆ [d1
 e], f(x(`)) = ` Â· . Then, FairToKWIK is an (, Î´)-KWIK algorithm for C with
KWIK bound m(, Î´), with m(, Î´) the solution to m(,Î´)
4 = R(m(, Î´), Î´
2T ).
Remark 3. The condition that C should contain a function that can take on values that are multiples
of  is for technical convenience; C can always be augmented by adding a single such function.
Our aim is to construct a KWIK algorithm B to predict labels for a sequence of examples
labeled with some unknown function fâˆ— âˆˆ C. To do this, we will run our fair contextual bandit
algorithm A on an instance that we construct online as examples xt arrive for B. The idea is to
simulate a two arm instance, in which one armâ€™s rewards are governed by fâˆ— (the function to be
KWIK learned), and the other armâ€™s rewards are governed by a function f that we can set to take
any value in {0, , 2, . . . , 1}. For each input xt, we perform a thought experiment and consider Aâ€™s
probability distribution over arms when facing a context which forces arm 2â€™s payoff to take each
of the values 0, âˆ—, 2âˆ—, . . . , 1. Since A is fair, A will play arm 1 with weakly higher probability than
arm 2 for those ` : `âˆ— â‰¤ f(xt); analogously, A will play arm 1 with weakly lower probability than
arm 2 for those ` : `âˆ— â‰¥ f(xt). If there are at least 2 values of ` for which arm 1 and arm 2 are
18
played with equal probability, one of those contexts will force A to suffer âˆ— regret, so we continue
the simulation of A on one of those instances selected at random, forcing at least âˆ—/2 regret in
expectation, and at the same time have B return âŠ¥. B receives fâˆ—(xt) on such a round, which is
used to construct feedback for A. Otherwise, A must transition from playing arm 1 with strictly
higher probability to playing 2 with strictly higher probability as ` increases: the point at which
that occurs will â€œsandwichâ€ the value of f(xt), since Aâ€™s fairness implies this transition must occur
when the expected payoff of arm 2 exceeds that of arm 1. B uses this value to output a numeric
prediction.
An important fact we exploit is that we can query Aâ€™s behavior on (xt, x(`)), for any xt and
` âˆˆ

d 1
âˆ— e

without providing it feedback (and instead â€œroll backâ€ its history to ht not including the
query (xt, x(`))). We update Aâ€™s history by providing it feedback only in rounds where B outputs
âŠ¥.
1: procedure FairToKWIK(, Î´, T)
2: âˆ— â† 
2, Î´âˆ— â† Î´Â·âˆ—
T , h â† [ ], initialize fair A(Î´âˆ—, T) for class C
3: for 1 â‰¤ t â‰¤ T do
4: ht â† h
5: for ` âˆˆ

d 1
âˆ— e

do
6: Let (pt,`
1 , pt,`
2 ) = (Ï€1|ht , Ï€2|ht )) be A(ht, (xt, x(`)))â€™s dist. over arms given h
7: if âˆƒ` 6= `0 : `, `0 âˆˆ

d 1
âˆ— e

: pt,`
1 = pt,`
2 = pt,`0
1 = pt,`0
2 then
8:
9: Choose x(Ë†
`) âˆˆR {x(`), x(`0)} . One of x(`), x(`0) must cause âˆ— regret
10: Select at âˆ¼ A(ht, (xt, x(Ë†
`))) . Run A to get a predicted arm
11: Predict yÌ‚t â† âŠ¥
12: if at = 1 then
13: rt
1 â† yt and h â† ht :: ((xt, x(Ë†
`)), 1, rt
1) . Use KWIK feedback
14: else
15: rt
2 â† Ë†
`âˆ—
16: h â† ht :: ((xt, x(Ë†
`)), 2, rt
2) . Construct feedback for arm 2
17: else . Aâ€™s history is not updated
18: if pt,`
1 â‰¤ pt,`
2 for all ` âˆˆ

d 1
âˆ— e

then
19: Ë†
` â† 0
20: else Let Ë†
` be the largest index for which pt,Ë†
`
1 > pt,Ë†
`
2
21: Predict yÌ‚t â† Ë†
` Â· âˆ—
Proof. For a fixed run of A, we calculate the probability that for all times t and ` âˆˆ

d 1
âˆ— e

, it
is the case that pt,`
1 > pt,`
2 only if fâˆ—(xt) > ` Â· âˆ— and also pt,`
1 < pt,`
2 only if fâˆ—(xt) < ` Â· âˆ—. In
this run, A is queried on T
âˆ— histories and contexts: prefixes of h along with (xt, x(`)) for each
t âˆˆ [T], ` âˆˆ

d 1
âˆ— e

. The fairness of A implies for any fixed ht and fixed (xt, x(`)), with probability
1 âˆ’ Î´âˆ—, pt,`
1 > pt,`
2 only if fâˆ—(xt) > `âˆ— and pt,`
1 < pt,`
2 only if fâˆ—(xt) < `âˆ—. Then, by a union bound
over t âˆˆ [T], ` âˆˆ

d 1
âˆ— e

, with probability at least 1 âˆ’ Î´âˆ— T
âˆ— = 1 âˆ’ Î´, A(ht, xt, x(`)) will satisfy this
property for all t âˆˆ [T], ` âˆˆ

d 1
âˆ— e

. We condition on this holding in the remainder of the proof.
We now argue that the numeric predictions of B are correct within an additive . Let:
Et
= {` : pt,`
1 = pt,`
2 }.
When B(xt) = yt âˆˆ [0, 1], note that |Et| â‰¤ 1, else B would have output âŠ¥.
19
If pt,`
1 â‰¤ pt,`
2 for all `, since |Et| â‰¤ 1, either pt,0
1 < pt,0
2 or pt,1
1 < pt,1
2 , which we have conditioned
on implying that either fâˆ—(xt) < f(x(0)) = 0 or fâˆ—(xt) < f(x(1)) = âˆ—. Since fâˆ—(xt) â‰¥ 0, this
implies fâˆ—(xt) âˆˆ [0, âˆ—) = [Ë†
`âˆ—, âˆ—) = [yÌ‚t, yÌ‚t + âˆ—).
Otherwise, we have that pt,Ë†
`
1 > pt,Ë†
`
2 , and pt,`
1 â‰¤ pt,`
2 for all ` > Ë†
`. If (a) Ë†
` = d 1
âˆ— e, then fâˆ—(xt) > 1,
a contradiction, so Ë†
` < d 1
âˆ— e. If (b) Ë†
` = d 1
âˆ— e âˆ’ 1, then fâˆ—(xt) > f(x(Ë†
`)) = (d 1
âˆ— e âˆ’ 1)âˆ— and so
fâˆ—(xt) âˆˆ ((d 1
âˆ— e âˆ’ 1)âˆ—, 1] = ( Ë†
yt, yÌ‚t + âˆ—], so Ë†
yt is âˆ—-accurate. If neither (a) nor (b), then (c) it
must be Ë†
` < d 1
âˆ— e âˆ’ 1. Since |Et| â‰¤ 1, for some ` âˆˆ {Ë†
` + 1, Ë†
` + 2}, we know that pt,`
1 < pt,`
2 ; thus,
fâˆ—(xt) < f(x(`)) â‰¤ (Ë†
` + 2)âˆ— and therefore fâˆ—(xt) âˆˆ (Ë†
`âˆ—, (Ë†
` + 2)âˆ—) = (yÌ‚t, yÌ‚t + 2âˆ—).
Finally, we upper-bound m(, Î´), the number of rounds t : B(xt) = âŠ¥. For each such t, A runs on
a random draw of one of two contexts, one of whose armsâ€™ payoffs differ by at least âˆ—. Thus, for one
of those contexts, either fâˆ—(xt) â‰¥ f(x)âˆ’âˆ— or fâˆ—(xt) â‰¤ f(x)âˆ’âˆ—. In either case, since pt,`
1 = pt,`
2 = 1
2
for x(`) = x, A suffers expected regret at least âˆ—
2 for that context, and at least âˆ—
4 when faced with
one chosen at random. Thus, m(, Î´) Â· âˆ—
4 = m(, Î´) Â· 
8 < R(m(, Î´), Î´âˆ—) = R(m(, Î´), Î´
2T ), since
Aâ€™s regret is upper bounded by this quantity over m(, Î´) rounds (which is an upper bound on the
number of rounds for which A is actually run and updated).
6.1 An Exponential Separation Between Fair and Unfair Learning
In this section, we exploit the other direction of the equivalence we have proven between fair
contextual bandit algorithms and KWIK learning algorithms to give a simple contextual bandit
problem for which fairness imposes an exponential cost in its regret bound. This is in contrast to
the case in which the underlying class of functions is linear, for which we gave fair contextual bandit
algorithms with regret bounds within a polynomial factor of their unconstrained counterparts. In
this problem, the context domain is the d-dimensional boolean hypercube: X = {0, 1}d â€“ i.e. the
context each round for each individual consists of d boolean attributes. Our class of functions C is
the class of boolean conjunctions:
C = {f | f(x) = xi1 âˆ§ xi2 âˆ§ . . . âˆ§ xik
where 0 â‰¤ k â‰¤ d and i1, . . . , ik âˆˆ [d]}.
We first give a simple but unfair algorithm, ConjunctionBandit, for this problem which
obtains a regret bound which is linear in d. It maintains a set of candidate variables Câˆ—
j for each
conjunction fj; this set shrinks across rounds, while always containing the true set of variables over
which fj is defined. We denote the boolean value of variable m in the context for arm j in round t
by xt
j,m.
The formal claim and proof that ConjunctionBandit achieves regret R(T) = O(k2d), as well
as ConjunctionBanditâ€™s formal description, can be found in Appendix C. ConjunctionBandit
violates the fairness in every round t in which it predicts 0 for arm i but 1 for arm j even though
fi(xt) = fj(xt) = 1, as Ï€t
i = 0 < 1
k < Ï€t
j.
We now show that fair algorithms cannot guarantee subexponential regret in d. This relies
upon a known lower bound for KWIK learning conjunctions [Li, 2009]:
Lemma 11. There exists a sequence of examples (x1, . . . , x2dâˆ’1) such that for , Î´ â‰¤ 1/2, every
(, Î´)-KWIK learning algorithm B for the class C of conjunctions on d variables must output âŠ¥ for
xt for each t âˆˆ [2d âˆ’ 1]. Thus, B has a KWIK bound of at least m(, Î´) = â„¦(2d).
We then use the equivalence between fair algorithms and KWIK learning to translate this lower
bound on m(, Î´) into a minimum worst case regret bound for fair algorithms on conjunctions. We
modify Theorem 6 to yield the following lemma, proven in Appendix C.
20
Lemma 12. Suppose A is a Î´-fair algorithm for the contextual bandit problem over the class C of
conjunctions on d variables. If A has regret bound R(T, Î´) then for Î´0 = 2TÎ´, FairToKWIK is an
(0, Î´0)-KWIK algorithm for C with KWIK bound m(0, Î´0) = 4R(m(0, Î´0), Î´).
Lemma 11 then lets us lower-bound the worst case regret of fair learning algorithms on con-
junctions.
Corollary 2. For Î´ < 1
2T , any Î´-fair algorithm for the contextual bandit problem over the class C
of conjunctions on d boolean variables has a worst case regret bound of R(T) = â„¦(2d).
Proof. Let T â‰¤ 2dâˆ’1. We know then that if Î´0 < 1, Lemma 11 guarantees the existence of a sequence
of contexts x1, . . . , xT for which any (0, Î´0)-KWIK algorithm has KWIK bound m(T, 0, Î´0) = T.
Lemma 12 implies 4R(m(T, 0, Î´0), Î´) gives a KWIK bound of m(T, 0, Î´0) when Î´0 = 2TÎ´. Thus,
if Î´ < 1
2T , then Î´0 < 1 and so R(m(T, 0, Î´0), Î´) = m(T,0,Î´0)
4 = T
4 .
Together with the analysis of ConjunctionBandit, this demonstrates a strong separation
between fair and unfair contextual bandit algorithms: when the underlying functions mapping
contexts to payoffs are conjunctions on d variables, there exist a sequence of contexts on which fair
algorithms must incur regret exponential in d while unfair algorithms can achieve regret linear in
d.
References
Philip Adler, Casey Falk, Sorelle A. Friedler, Gabriel Rybeck, Carlos Scheidegger, Brandon Smith, and Suresh
Venkatasubramanian. Auditing black-box models by obscuring features. CoRR, abs/1602.07043, 2016. URL
http://arxiv.org/abs/1602.07043.
Alekh Agarwal, Daniel J. Hsu, Satyen Kale, John Langford, Lihong Li, and Robert E. Schapire. Taming the monster:
A fast and simple algorithm for contextual bandits. In Proceedings of the 31th International Conference on Machine
Learning, ICML 2014, Beijing, China, 21-26 June 2014, pages 1638â€“1646, 2014.
Kareem Amin, Michael Kearns, and Umar Syed. Graphical models for bandit problems. arXiv preprint
arXiv:1202.3782, 2012.
Kareem Amin, Michael Kearns, Moez Draief, and Jacob D Abernethy. Large-scale bandit problems and kwik learning.
In Proceedings of the 30th International Conference on Machine Learning (ICML-13), pages 588â€“596, 2013.
Peter Auer, Nicolo Cesa-Bianchi, and Paul Fischer. Finite-time analysis of the multiarmed bandit problem. Machine
learning, 47(2-3):235â€“256, 2002.
Solon Barocas and Andrew D. Selbst. Big dataâ€™s disparate impact. California Law Review, 104, 2016. Available at
SSRN: http://ssrn.com/abstract=2477899.
Anna Maria Barry-Jester, Ben Casselman, and Dana Goldstein. The new science of sentencing. The Marshall Project,
August 8 2015. URL https://www.themarshallproject.org/2015/08/04/the-new-science-of-sentencing. Re-
trieved 4/28/2016.
Alina Beygelzimer, John Langford, Lihong Li, Lev Reyzin, and Robert E. Schapire. Contextual bandit algorithms with
supervised learning guarantees. In Proceedings of the Fourteenth International Conference on Artificial Intelligence
and Statistics, AISTATS 2011, Fort Lauderdale, USA, April 11-13, 2011, pages 19â€“26, 2011.
SeÌbastien Bubeck and Nicolo Cesa-Bianchi. Regret analysis of stochastic and nonstochastic multi-armed bandit
problems. Machine Learning, 5(1):1â€“122, 2012.
Nanette Byrnes. Artificial intolerance. MIT Technology Review, March 28 2016. URL https://www.
technologyreview.com/s/600996/artificial-intolerance/. Retrieved 4/28/2016.
21
Toon Calders and Sicco Verwer. Three naive bayes approaches for discrimination-free classification. Data Mining and
Knowledge Discovery, 21(2):277â€“292, 2010.
Wei Chu, Lihong Li, Lev Reyzin, and Robert E. Schapire. Contextual bandits with linear payoff functions. In
Proceedings of the Fourteenth International Conference on Artificial Intelligence and Statistics, AISTATS 2011,
Fort Lauderdale, USA, April 11-13, 2011, pages 208â€“214, 2011.
Cary Coglianese and David Lehr. Regulating by robot: Administrative decision-making in the machine-learning era.
Georgetown Law Journal, 2016. Forthcoming.
Cynthia Dwork, Moritz Hardt, Toniann Pitassi, Omer Reingold, and Richard Zemel. Fairness through awareness. In
Proceedings of the 3rd Innovations in Theoretical Computer Science Conference, pages 214â€“226. ACM, 2012.
Michael Feldman, Sorelle A. Friedler, John Moeller, Carlos Scheidegger, and Suresh Venkatasubramanian. Certifying
and removing disparate impact. In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge
Discovery and Data Mining, Sydney, NSW, Australia, August 10-13, 2015, pages 259â€“268, 2015.
Benjamin Fish, Jeremy Kun, and AÌdaÌm D Lelkes. A confidence-based approach for balancing fairness and accuracy.
SIAM International Symposium on Data Mining, 2016.
FTC Commisioner Julie Brill. Navigating the â€œtrackless oceanâ€: Fairness in big data research and decision making.
Keynote Address at the Columbia University Data Science Institute, April 2015.
Toshihiro Kamishima, Shotaro Akaho, and Jun Sakuma. Fairness-aware learning through regularization approach.
In Data Mining Workshops (ICDMW), 2011 IEEE 11th International Conference on, pages 643â€“650. IEEE, 2011.
Michael N Katehakis and Herbert Robbins. Sequential choice from several populations. PROCEEDINGS-NATIONAL
ACADEMY OF SCIENCES USA, 92:8584â€“8584, 1995.
Tze Leung Lai and Herbert Robbins. Asymptotically efficient adaptive allocation rules. Advances in applied mathe-
matics, 6(1):4â€“22, 1985.
Lihong Li. A unifying framework for computational reinforcement learning theory. PhD thesis, Rutgers, The State
University of New Jersey, 2009.
Lihong Li, Michael L Littman, Thomas J Walsh, and Alexander L Strehl. Knows what it knows: a framework for
self-aware learning. Machine learning, 82(3):399â€“443, 2011.
Binh Thanh Luong, Salvatore Ruggieri, and Franco Turini. k-nn as an implementation of situation testing for
discrimination discovery and prevention. In Proceedings of the 17th ACM SIGKDD international conference on
Knowledge discovery and data mining, pages 502â€“510. ACM, 2011.
Clair C Miller. Can an algorithm hire better than a human? The New York Times, June 25 2015. URL http://www.
nytimes.com/2015/06/26/upshot/can-an-algorithm-hire-better-than-a-human.html. Retrieved 4/28/2016.
Cecilia Munoz, Megan Smith, and DJ Patil. Big data: A report on algorithmic systems, opportunity, and civil rights.
Technical report, Executive Office of the President, The White House, 2016.
John Podesta, Penny Pritzker, Ernest J. Moniz, John Holdern, and Jeffrey Zients. Big data: Seizing opportunities,
protecting values. Technical report, Executive Office of the President, The White House, 2014.
Cynthia Rudin. Predictive policing using machine learning to detect patterns of
crime. Wired Magazine, August 2013. URL http://www.wired.com/insights/2013/08/
predictive-policing-using-machine-learning-to-detect-\patterns-of-crime/. Retrieved 4/28/2016.
Alexander L Strehl and Michael L Littman. Online linear regression and its application to model-based reinforcement
learning. In Advances in Neural Information Processing Systems, pages 1417â€“1424, 2008.
Latanya Sweeney. Discrimination in online ad delivery. Commununications of the ACM, 56(5):44â€“54, 2013.
Rich Zemel, Yu Wu, Kevin Swersky, Toni Pitassi, and Cynthia Dwork. Learning fair representations. In Proceedings
of the 30th International Conference on Machine Learning (ICML-13), pages 325â€“333, 2013.
22
A Missing Proofs for the Classic Stochastic Bandits Upper Bound
We begin by proving Lemma 1, used in Section 3 to prove the fairness of the FairBandits algo-
rithm.
Proof of Lemma 1. Choose an arbitrary arm i and round t and define indicator variables X1, . . . , Xni(t)
where Xn takes on the reward of pull n of arm i. By a Chernoff bound, for any a â‰¥ 0,
P

|ÂµÌ‚t
i âˆ’ Âµi| â‰¤
a
nt
i

â‰¤ 2 exp(âˆ’2a2
/nt
i).
In particular for a =
p
nt
i ln((Ï€t)2/3Î´)/2, it is the case that
P
"
Âµi 6âˆˆ ÂµÌ‚t
i âˆ’
s
ln((Ï€t)2/3Î´)
2nt
i
, ÂµÌ‚t
i +
s
ln((Ï€t)2/3Î´)
2nt
i
!#
â‰¤2 exp(âˆ’2nt
i ln((Ï€t)2
/3Î´)/2nt
i) = 2 exp(ln(3Î´/(Ï€t)2
)) = 6Î´/(Ï€t)2
.
By a union bound over all rounds t, the probability of any true mean ever falling outside of its
confidence interval is at most Î´( 6
Ï€2
Pâˆ
t=1
1
t2 ) = Î´.
Next, we prove Lemma 2, which we used in Section 3 to bound the regret of FairBandits in
Theorem 2.
Proof of Lemma 2. Let X1, ..., Xt be indicator variables of whether i was pulled at each time t0 âˆˆ [t].
Let Mt =
P
t0â‰¤t Xt0 , with E [Mt] = pt. For any  âˆˆ [0, 1], a standard additive Chernoff bound states
that
P [Mt â‰¤ pt âˆ’ t] â‰¤ eâˆ’2t2
.
Since i âˆˆ St, it must be that i âˆˆ St0
for all t0 â‰¤ t and all i âˆˆ St, by the definition of FairBandits.
Thus, P [Xi = 1] â‰¥ 1
k for any i âˆˆ St, and therefore pt â‰¥ t
k . so this also implies that
P

Mt â‰¤
t
k
âˆ’ t

â‰¤ eâˆ’2t2
.
Setting t =
r
t ln(2t2k
Î´
)
2 , this bound becomes
P
ï£®
ï£°Mt â‰¤
t
k
âˆ’
s
t ln(2t2k
Î´ )
2
ï£¹
ï£» â‰¤
Î´
2kt2
as desired. Then, taking a union bound over all active arms of which there are at most k, the claim
follows.
Proof of Lemma 3. This follows from the definition of `t
i, ut
i and the lower bound on nt
i provided
by the assumption of the lemma.
23
A.1 Missing Derivation of R(T) for Theorem 2
R(T) â‰¤
T
X
t:0
min(1, k Â· Î·(t)) +

1 +
Ï€
2

Î´T
â‰¤
T
X
t:0
k Â· min(1, Î·(t)) +

1 +
Ï€
2

Î´T
â‰¤ k
ï£«
ï£¬
ï£¬
ï£­
T
X
t: t
k
>2
q
t ln tk
Î´
v
u
u
t
ln t
Î´
t
k âˆ’
q
t ln tk
Î´
+
T
X
t: t
k
â‰¤2
q
t ln tk
Î´
1
ï£¶
ï£·
ï£·
ï£¸ + O(Î´)T
â‰¤ k
ï£«
ï£¬
ï£¬
ï£­
T
X
t: t
k
>2
q
t ln tk
Î´
s
ln t
Î´
t
2k
+
T
X
t: t
k
â‰¤2
q
t ln tk
Î´
1
ï£¶
ï£·
ï£·
ï£¸ + O(Î´T)
â‰¤ k
Z T
t=0
s
ln t
Î´
t
2k
+
Z OÌƒ(k2 ln k
Î´
)
t=1
1
!
+ O(Î´T)
â‰¤ k
3
2
Z T
t=1
s
ln t
Î´
t
+ OÌƒ(k3
ln
k
Î´
) + O(Î´T)
= k
3
2
âˆš
2T
r
ln
kT
Î´
+ OÌƒ(k3
ln
k
Î´
) + O(Î´T)
= OÌƒ(k
3
2
r
T ln
kT
Î´
+ k3
) + O(Î´T)
= OÌƒ(k
3
2
r
T ln
kT
Î´
+ k3
)
where the final step follows from Î´ â‰¤ 1
âˆš
T
.
B Missing Proofs for the Classic Stochastic Bandits Lower Bound
All lemmas in this section are used in Section 4 to prove the fair lower bound in Theorem 3. The
first, Lemma 4, lets us analyze distributions over payoffs.
Proof of Lemma 4. Let Ri represent the joint distribution on rewards for either experiment: in
both cases, the joint distribution on rewards is identical, since the process which generates them is
the same.
We will use the notation m, d1, . . . , dt to represent some fixed realization of the random variables
Âµi, r1
i , . . . , rt
i and Âµ0
i, r1
i , . . . , rt
i. In particular, it suffices to show that
P(Âµi,r1
i ,...,rt
i )âˆ¼W

(Âµi, r1
i , . . . , rt
i) = (m, d1
, . . . , dt
)

= P(Âµ0
i,r1
i ,...,rt
i )âˆ¼W0

(Âµ0
i, r1
i , . . . , rt
i) = (m, d1
, . . . , dt
)

.
The first experiment which generates (Âµi, r1
i , . . . , rt
i) according to W has probability mass on this
particular value of its random variables:
P(Âµi,r1
i ,...,rt
i )âˆ¼W

(Âµi, r1
i , . . . , rt
i) = (m, d1
, . . . , dt
)

= PÂµiâˆ¼Pi [Âµi = m] Â· Pr1
i ,...,rt
i âˆ¼B(Âµi)

(r1
i , . . . , rt
i) = (d1
, . . . , dt
)

24
The second experiment has joint probability:
P(Âµ0
i,r1
i ,...,rt
i )âˆ¼W0

(Âµ0
i, r1
i , . . . , rt
i) = (m, d1
, . . . , dt
)

= PÂµ0
iâˆ¼Pi(r1
i ,...,rt
i )

Âµ0
i = m

Â· P(r1
i ,...,r1
t )âˆ¼Ri

(r1
i , . . . , r1
t ) = (d1
, . . . , dt
)

= P(Âµ0
i,r1
i ,...,rt
i )âˆ¼W

(Âµ0
i, r1
i , . . . , rt
i) = (m, d1
, . . . , dt
)

where equality follows from Bayesâ€™ Rule.
Next, we prove Lemma 5, used to reason about distinguishing between arms.
Proof of Lemma 5. Since neither i nor i + 1 is
âˆš
Î´-distinguished by ht, for any Î±i âˆˆ {1
3 + i
3k , 1
3 +
i+1
3k }, Î±i+1 âˆˆ {1
3 + i+1
3k , 1
3 + i+2
3k }, the posterior probability of Âµi = Î±i is less than 1 âˆ’
âˆš
Î´, and in
particular for Î± = 1
3 + i+1
3k , it must be the case that
PÂµiâˆ¼Pi(ht) [Âµi = Î±] >
âˆš
Î´ and also PÂµi+1âˆ¼Pi(ht) [Âµi+1 = Î±] >
âˆš
Î´.
Since P =
Q
i Pi, we know that
PÂµi,Âµi+1âˆ¼P(ht) [Âµi = Î± = Âµi+1] = PÂµiâˆ¼Pi(ht) [Âµi = Î±] Â· PÂµi+1âˆ¼Pi+1(ht) [Âµi+1 = Î±] > Î´
which completes the proof.
Finally, we prove Lemma 6, which lets us reason about how fair algorithm choices depend on
histories.
Proof of Lemma 6. We will define a set of histories which cause A to play some pair of arms
i and i + 1 with different probabilities when Âµi = Âµi+1. Define the set unfair(A, Âµ) such that
ht âˆˆ unfair(A, Âµ) if there exist i âˆˆ [k âˆ’ 1], t0 âˆˆ [t] such that Âµi = Âµi+1 but Ï€t0
i|ht0 6= Ï€t0
i+1|ht0 .
Consider some ht which has not
âˆš
2Î´-distinguished any arm, such that there exists some i, t0 for
which Ï€t0
i|ht0 6= 1
k . Then, in particular, there exists some i âˆˆ [k âˆ’ 1] such that Ï€t0
i|ht0 6= Ï€t0
i+1|ht0 . By
Lemma 5, for all i and in particular this i, it is the case that 2Î´ < PÂµ0âˆ¼P|ht

Âµ0
i = Âµ0
i+1

= X and so
2Î´ < X = PÂµ0âˆ¼P|ht
h
Âµ0
i = Âµ0
i+1 âˆ© Ï€t0
i|ht 6= Ï€t0
i+1|ht
i
â‰¤ PÂµ0âˆ¼P|ht

ht
âˆˆ unfair(A, Âµ0
)

(4)
where the first equality comes from the fact that ht is a history for which Ï€t0
i|ht 6= Ï€t0
i+1|ht and the
second equality from the definition of the set unfair.
We will show that Equation 4 cannot hold with probability more than 1
2 over the draw of Âµ, ht
from the underlying distribution, or else A would not satisfy Î´-fairness. Since A is Î´-fair, for any
fixed Âµ
Î´ â‰¥ Phtâˆ¼A|Âµ

ht
âˆˆ unfair(A, Âµ)

and therefore for any distribution P over Âµ that
Î´ â‰¥ PÂµâˆ¼P,htâˆ¼A|Âµ

ht
âˆˆ unfair(A, Âµ)

.
Lemma 4 implies also Î´ â‰¥ PÂµâˆ¼P,htâˆ¼A|Âµ,Âµ0âˆ¼P|ht

ht âˆˆ unfair(A, Âµ0)

, so by Markovâ€™s inequality
1
2
â‰¥ PÂµâˆ¼P,htâˆ¼A|Âµ

PÂµ0âˆ¼P|ht

ht
âˆˆ unfair(A, Âµ0
)

â‰¥ 2Î´

.
25
Thus, with probability at least 1
2 over the distribution over histories and means,
PÂµ0âˆ¼P|ht

ht
âˆˆ unfair(A, Âµ0
)

â‰¤ 2Î´.
However, Equation 4 shows this does not hold for any ht which does not
âˆš
2Î´-distinguish any arm
but for which Ï€t0
i|ht0 6= 1
k for some i âˆˆ [k], t0 â‰¤ t. Thus, for at least 1
2 of all probability mass over
histories, either Ï€t0
i|ht0 = 1
k for all i, t0 â‰¤ t, or ht must
âˆš
2Î´-distinguish some arm.
C Missing Proofs for the Contextual Bandit Setting
We begin by proving two results related to KWIKToFair. The first, Lemma 8, was used in Section
5 to prove that KWIKToFair is Î´-fair in Theorem 5.
Proof of Lemma 8. We will refer to a violation of either (a) or (b) as a failure of learner Li.
For each Li, the set of queries asked of it are pairs (hi, xt
i), histories along with new contexts.
There are at most T contexts queried, and at most T histories on which Li is queried for a
fixed run of our algorithm (namely, prefixes of Liâ€™s final history). Thus, there are at most T2
queries for Li. Thus, by a union bound over these T2 queries for learner Li, by the KWIK
guarantee, P [Li fails in some round] â‰¤ T2Î´âˆ— = min(Î´, 1
T )/k, and by a union bound over k arms,
P [A learner fails in a round] â‰¤ min(Î´, 1
T ).
We proceed to Theorem 4, used in Section 5 to construct a Î´-fair algorithm with quantified
regret from KWIK learners.
Proof of Theorem 4. We use repeated calls to KWIKToFair (Î´, T) to run for an indefinite number
of rounds. Specifically, we will make calls E = 1, 2, . . . to KWIKToFair (6Î´/Ï€(log(T)2, 2E). We
will refer to each such call to KWIKToFair by its epoch E. By Lemma 8, each epoch E is
6Î´/Ï€E2k-fair, i.e. has a 6Î´/Ï€E2k probability of violating fairness. Therefore by a union bound
across epochs, the probability of ever violating fairness through repeated calls to KWIKToFair
is bounded above by
Pâˆ
E=1
6Î´
(Ï€E)2 = 6Î´
Ï€2
Pâˆ
E=1
1
E2 = Î´, so the overall algorithm is Î´-fair.
Next, by Lemma 9 each epoch E contributes at most regret 3 Â· 2Ekâˆ—
E where âˆ—
E denotes the
value of âˆ— used in epoch E, i.e. âˆ—
E satisfying âˆ—
E = k Â·m(âˆ—
E, 6Î´/Ï€E2, 2E). Then since each epoch E
covers 2E rounds, through round T the algorithm has used fewer than log(T) epochs, and by the
doubling trick achieves regret R(T) <
Plog(T)
E=1 3 Â· 2Ekâˆ—
E = O(Tkâˆ—) = O(k2 Â· m(âˆ—, Î´âˆ—)).
Next, we address the special subcase of KWIKToFair for linear functions outlined in Corollary
1.
Proof of Corollary 1. By Lemma 10, for each arm j the associated learner Lj has mistake bound
m(, Î´) = OÌƒ(d3/4). Since âˆ— satisfies âˆ— = k Â· m(âˆ—, Î´)/T we get âˆ— =

kd3
T
1/5
Substituting this
into Theorem 4, the overall regret guarantee satisfies regret R(T) = O(k2 Â· m(âˆ—, Î´âˆ—)) = O(Tkâˆ—) =
O(T4/5k6/5d3/5).
This brings us to the formal algorithm description of ConjunctionBandit and its correspond-
ing regret bound, used in Section 6.1 as an example of an unfair learning algorithm for conjunctions.
1: procedure ConjunctionBandit
2: Let Câˆ—
j â† {1, 2, . . . , d} for all j âˆˆ [k] . Initialize set of candidate variables for fj
26
3: for t = 1, 2, . . . do
4: St â† âˆ… . Initialize active set of arms
5: for j = 1, 2, . . . , k do
6: if âˆ§mâˆˆCâˆ—
j
xt
j,m = 1 then
7: St â† St âˆª {j} . Add arm j to active set
8: if St = âˆ… then
9: Pull arm jâˆ— â† (x âˆˆR [k]) . Pull arm at random
10: if rt
jâˆ— = 1 then
11: Câˆ—
jâˆ— â† Câˆ—
jâˆ— \ {m | xt
j,m = 0}
12: else
13: Pull arm jâˆ— â† (x âˆˆR St) . Pull arm from active set at random
We can now upper bound the regret achieved by ConjunctionBandit.
Lemma 13. ConjunctionBandit achieves regret R(T) = O(k2d).
Proof of Lemma 13. First, we claim that for every j, for the duration of the algorithm, that Cj âŠ†
Câˆ—
j , where Cj is the true set of variables corresponding to fj. This holds at initialization: Cj âŠ† [d] =
Câˆ—
j . Suppose the claim holds prior to round t: if Câˆ—
j is updated in this round, then fj(xt
j) = 1 â‡’
âˆ€m âˆˆ [d] : xt
j,m = 0, m /
âˆˆ Cj. Thus, Câˆ—
j = Câˆ—
j \{m : xt
j,m = 0} = Câˆ—
j \{m : xt
j,m = 0âˆ©m /
âˆˆ Cj} âŠƒ Cj.
Therefore, the algorithm never makes false positive mistakes: in any round t, j âˆˆ St â‡’ fj(xt
j) =
1. Therefore ConjunctionBandit only accumulates regret in rounds where it makes false negative
mistakes by predicting that all arms have reward 0 when some arm has reward 1.
Then, we have Regret(x1, . . . , xT ) =
P
t maxj

fj(xt
j)

âˆ’ E
P
t fit (xt
it )

. We then rewrite the
first term as
P
t maxj

fj(xt
j)

=
P
t I{fj(xt
j) = 1 for some j âˆˆ [k]} and the second term as
E
"
X
t
fit (xt
it )
#
= T âˆ’ E
"
X
t
I{St
= âˆ… âˆ§ fjâˆ— (xt
jâˆ— ) = 0 âˆ§ fj(xt
j) = 1 for some j âˆˆ [k]}
#
â‰¥ T âˆ’ E
"
X
t
I{fjâˆ— (xt
jâˆ— ) = 0 | St
= âˆ… âˆ§ fj(xt
j) = 1 for some j âˆˆ [k]}
#
â‰¥ T âˆ’
X
jâˆˆ[k]
E
"
X
t
I{fjâˆ— (xt
jâˆ— ) = 0 | St
= âˆ… âˆ§ fj(xt
j) = 1}
#
â‰¥ T âˆ’
X
jâˆˆ[k]
kd = T âˆ’ k2
d
where the last inequality follows from P
h
jâˆ— = j | St = âˆ… âˆ§ fj(xt
j) = 1
i
= 1
k and the fact that if
St = âˆ… and fjâˆ— (xt
jâˆ— ) = 1 then Cjâˆ— loses at least one of d variables, and this loss can therefore occur
at most d times for each arm j. Substituting this into the original regret expression then yields
Regret(x1
, . . . , xT
) â‰¤
X
t
I{fj(xt
j) = 1 for some j âˆˆ [k]} âˆ’ (T âˆ’ k2
d)
â‰¤ T âˆ’ (T âˆ’ k2
d) â‰¤ k2
d.
27
Finally, we prove Lemma 12, which we used in Section 6.1 to translate between fair and KWIK
learning on conjunctions.
Proof of Lemma 12. We mimic the structure of the proof of Theorem 6, once again using Fair-
ToKWIK to construct a KWIK learner B by running the given fair algorithm A on a constructed
bandit instance for each context xt.
There are two primary modifications for the specific case of conjunctions: as conjunctions output
either 0 or 1 we set  = 0, âˆ— = 1, and Î´âˆ— = Î´
2T . A therefore runs on 2T histories and contexts,
either of form (xt, x(0) = 0) or (xt, x(1) = 1). Since we initialize A to be Î´âˆ—-fair, if we fix history ht
along with context and arm assignment (xt, x(`)) then, with probability at least 1 âˆ’ Î´âˆ—, pt,`
1 > pt,`
2
implies fâˆ—(xt) > `/2 and similarly pt,`
2 > pt,`
1 implies fâˆ—(xt) < `/2. Union bounding over all such
t and ` yields that A satisfies this fairness over all t and ` with probability at least 1 âˆ’ Î´, and we
condition on this event for the rest of the proof.
We proceed to prove that the resulting KWIK learner B is -accurate. Here, as  = 0, this
requires showing that all of Bâ€™s numerical predictions are correct. Assume instead that B outputs
an incorrect prediction on (xt, x(`)). By the construction of FairToKWIK, a prediction from B
implies that at least one of pt,0
1 , pt,1
1 , pt,0
2 and pt,1
2 is distinct from the others. We condition on this
distinctness to get two cases.
In the first case, pt,`
1 â‰¤ pt,`
2 for both ` = 0 and 1. By distinctness, this means that either pt,0
1 < pt,0
2
or pt,1
1 < pt,1
2 . By the fairness assumption, this respectively implies that fâˆ—(xt) < f(x(0)) = 0 or
fâˆ—(xt) < f(x(1)) = 1. In either event, fâˆ—x(t) = 0 = yÌ‚t. In the second case, pt,`
1 > pt,`
2 for at least
one of ` = 0 or 1. pt,1
1 > pt,1
2 violates the fairness assumption on A as f(x(1)) = 1, so it must be
that pt,0
1 > pt,0
2 . Fairness then implies that fâˆ—(xt) = 1 = yÌ‚t. Therefore B is -accurate.
It remains to upper bound m(, Î´). Any round where B outputs âŠ¥ means a choice between
two contexts, one of which has a difference of 1 between arms. It follows that choosing randomly
between both arms and contexts incurs expected regret 1/4. Therefore m(,Î´)
4 < R(m(, Î´), Î´âˆ—, d) =
R(m(, Î´), Î´
2T , d).
28
